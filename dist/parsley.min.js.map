{"version":3,"sources":["/source/parsley.js","/source/src/parsley/pubsub.js","/source/src/parsley/utils.js","/source/src/parsley/defaults.js","/source/src/parsley/abstract.js","/source/src/parsley/validator.js","/source/src/parsley/validator_registry.js","/source/src/parsley/ui.js","/source/src/parsley/form.js","/source/src/parsley/factory/constraint.js","/source/src/parsley/field.js","/source/src/parsley/multiple.js","/source/src/parsley/factory.js","/source/src/parsley.js"],"names":["global","factory","exports","module","require","define","amd","parsley","$","this","adapt","fn","context","parsleyAdaptedCallback","args","Array","prototype","slice","call","arguments","unshift","apply","o","eventName","name","lastIndexOf","eventPrefix","substr","length","globalID","pastWarnings","ParsleyUtils__ParsleyUtils","attr","$element","namespace","obj","i","attribute","attributes","regex","RegExp","hasOwnProperty","specified","test","camelize","deserializeValue","value","checkAttr","_checkAttr","is","setAttr","setAttribute","dasherize","String","generateID","num","isNaN","Number","parseJSON","e","str","replace","match","chr","toUpperCase","toLowerCase","warn","window","console","warnOnce","msg","_resetWarnings","trimString","string","objectCreate","Object","create","Error","TypeError","result","ParsleyUtils__default","ParsleyDefaults","inputs","excluded","priorityEnabled","multiple","group","uiEnabled","validationThreshold","focus","trigger","errorClass","successClass","classHandler","ParsleyField","errorsContainer","errorsWrapper","errorTemplate","ParsleyAbstract","asyncSupport","actualizeOptions","options","domOptions","parent","_resetOptions","initOptions","_listeners","on","queue","push","subscribe","listenTo","off","splice","unsubscribe","unsubscribeTo","target","extraArg","reset","__class__","_trigger","fields","destroy","removeData","asyncIsValid","whenValid","_findRelatedMultiple","find","requirementConverters","_string","integer","parseInt","number","parseFloat","reference","boolean","object","regexp","_regexp","flags","convertArrayRequirement","m","values","split","map","convertRequirement","requirementType","converter","convertExtraOptionRequirement","requirementSpec","extraOptionReader","main","extra","key","ParsleyValidator","spec","extend","validate","requirementFirstArg","isArray","validateMultiple","validateNumber","validateString","parseRequirements","requirements","type","isPlainObject","priority","ParsleyValidatorRegistry","validators","catalog","locale","init","typeRegexes","email","digits","alphanum","url","range","addValidator","Parsley","setLocale","addCatalog","messages","set","addMessage","message","arg1","arg2","ParsleyUtils","_setValidator","updateValidator","removeValidator","validator","getErrorMessage","constraint","typeMessages","formatMessage","defaultMessage","en","parameters","notblank","required","pattern","minlength","requirement","maxlength","min","max","mincheck","maxcheck","check","equalto","refOrValue","$reference","val","ParsleyUI","listen","that","setupForm","setupField","reflow","fieldInstance","_ui","active","diff","_diff","validationResult","lastValidationResult","validatedOnce","manageStatusClass","manageErrorsMessages","actualizeTriggers","kept","added","failedOnce","manageFailingFieldTrigger","getErrorsMessages","_getErrorMessage","assert","hasConstraints","needsValidation","_successClass","_errorClass","_resetClass","errorsMessagesDisabled","errorMessage","_insertErrorWrapper","$errorsWrapper","append","addClass","html","removeClass","remove","removed","removeError","addError","undefined","updateError","doNotUpdateClass","formInstance","_focusedField","field","noFocus","customConstraintErrorMessage","newResult","oldResult","deep","found","j","proxy","onSubmitValidate","__id__","$errorClassHandler","_manageClassHandler","errorsWrapperId","validationInformationVisible","$handler","$errorsContainer","$from","after","$toBind","triggers","join","eventValidate","event","getValue","each","parsleyInstance","children","ParsleyForm","element","ParsleyForm__statusMapping","pending","resolved","rejected","stopImmediatePropagation","preventDefault","whenValidate","done","_submit","always","_submitSource","appendTo","Event","force","state","submitEvent","_refreshFields","promises","_withoutReactualizingFormOptions","_isFieldInGroup","when","fail","isValid","inArray","_bindFields","self","oldFields","fieldsMappedById","not","Factory","oldActualizeOptions","ConstraintFactory","parsleyField","isDomConstraint","validatorSpec","_validatorRegistry","_parseRequirements","capitalize","cap","instance","requirementList","parsleyFormInstance","constraints","constraintsByName","_bindConstraints","parsley_field__statusMapping","promise","_isRequired","validateIfEmpty","refreshConstraints","groupedConstraints","_getGroupedConstraints","_","_validateConstraint","Deferred","reject","_handleWhitespace","addConstraint","removeConstraint","updateConstraint","_bindHtml5Constraints","hasClass","trimValue","whitespace","index","p","sort","a","b","parsley_field","ParsleyMultiple","addElement","$elements","fieldConstraints","has","data","filter","_init","ParsleyFactory","savedparsleyFormInstance","__version__","bind","isMultiple","handleMultiple","parsleyMultipleInstance","$previouslyRelated","get","doNotStore","ParsleyExtend","deprecated","callback","unsubscribeAll","emit","instanceGiven","parsley__Parsley","document","version","psly","instances","ParsleyConfig","registry","i18n","method","autoBind"],"mappings":"CAAC,SAAUA,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,WAC9E,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,UAAWJ,GAChED,EAAOO,QAAUN,EAAQD,EAAOQ,IAChCC,KAAM,SAAUD,GAAK,YCOvB,SAASE,GAAMC,EAAIC,GASjB,MAPKD,GAAGE,yBACNF,EAAGE,uBAAyB,WAC1B,GAAIC,GAAOC,MAAMC,UAAUC,MAAMC,KAAKC,UAAW,EACjDL,GAAKM,QAAQX,MACbE,EAAGU,MAAMT,GAAWU,EAAGR,KAGpBH,EAAGE,uBAKZ,QAASU,GAAUC,GACjB,MAAyC,KAArCA,EAAKC,YAAYC,EAAa,GACzBF,EAAKG,OAAOD,EAAYE,QAC1BJ,EC5BT,GAAIK,GAAW,EACbC,KADFC,GAMEC,KAAM,SAAUC,EAAUC,EAAWC,GACnC,GACEC,GAAGC,EAAWC,EACdC,EAAQ,GAAIC,QAAO,IAAMN,EAAW,IAEtC,IAAI,mBAAuBC,GACzBA,SAGA,KAAKC,IAAKD,GACJA,EAAIM,eAAeL,UACdD,GAAIC,EAIjB,IAAI,mBAAuBH,IAAY,mBAAuBA,GAAS,GACrE,MAAOE,EAGT,KADAG,EAAaL,EAAS,GAAGK,WACpBF,EAAIE,EAAWV,OAAQQ,KAC1BC,EAAYC,EAAWF,GAEnBC,GAAaA,EAAUK,WAAaH,EAAMI,KAAKN,EAAUb,QAC3DW,EAAI1B,KAAKmC,SAASP,EAAUb,KAAKP,MAAMiB,EAAUN,UAAYnB,KAAKoC,iBAAiBR,EAAUS,OAIjG,OAAOX,IAGTY,UAAW,SAAUd,EAAUC,EAAWc,GACxC,MAAOf,GAASgB,GAAG,IAAMf,EAAYc,EAAY,MAGnDE,QAAS,SAAUjB,EAAUC,EAAWF,EAAMc,GAC5Cb,EAAS,GAAGkB,aAAa1C,KAAK2C,UAAUlB,EAAYF,GAAOqB,OAAOP,KAGpEQ,WAAY,WACV,MAAO,GAAKzB,KAKdgB,iBAAkB,SAAUC,GAC1B,GAAIS,EAEJ,KACE,MAAOT,GACI,QAATA,IACU,SAATA,GAAmB,EACX,QAATA,EAAkB,KACjBU,MAAMD,EAAME,OAAOX,IACpB,UAAUH,KAAKG,GAAStC,EAAEkD,UAAUZ,GACpCA,EAF8BS,GAG5BT,EACJ,MAAOa,GAAK,MAAOb,KAIvBF,SAAU,SAAUgB,GAClB,MAAOA,GAAIC,QAAQ,UAAW,SAAUC,EAAOC,GAC7C,MAAOA,GAAMA,EAAIC,cAAgB,MAKrCZ,UAAW,SAAUQ,GACnB,MAAOA,GAAIC,QAAQ,MAAO,KACvBA,QAAQ,wBAAyB,SACjCA,QAAQ,oBAAqB,SAC7BA,QAAQ,KAAM,KACdI,eAGLC,KAAM,WACAC,OAAOC,SAAW,kBAAsBD,QAAOC,QAAQF,MACzDC,OAAOC,QAAQF,KAAK7C,MAAM8C,OAAOC,QAASjD,YAG9CkD,SAAU,SAASC,GACZxC,EAAawC,KAChBxC,EAAawC,IAAO,EACpB7D,KAAKyD,KAAK7C,MAAMZ,KAAMU,aAI1BoD,eAAgB,WACdzC,MAGF0C,WAAY,SAASC,GACnB,MAAOA,GAAOZ,QAAQ,aAAc,KAItCa,aAAcC,OAAOC,QAAU,WAC7B,GAAID,GAAS,YACb,OAAO,UAAU3D,GACf,GAAIG,UAAUS,OAAS,EACrB,KAAMiD,OAAM,gCAEd,IAAwB,gBAAb7D,GACT,KAAM8D,WAAU,6BAElBH,GAAO3D,UAAYA,CACnB,IAAI+D,GAAS,GAAIJ,EAEjB,OADAA,GAAO3D,UAAY,KACZ+D,OAlHbC,EAAAjD,ECKIkD,GAIF/C,UAAW,gBAGXgD,OAAQ,0BAGRC,SAAU,gFAGVC,iBAAiB,EAKjBC,SAAU,KAGVC,MAAO,KAIPC,WAAW,EAGXC,oBAAqB,EAGrBC,MAAO,QAGPC,SAAS,EAGTC,WAAY,gBAGZC,aAAc,kBAIdC,aAAc,SAAUC,KAIxBC,gBAAiB,SAAUD,KAG3BE,cAAe,wCAGfC,cAAe,aCzDbC,EAAkB,YAEtBA,GAAgBlF,WACdmF,cAAc,EAEdC,iBAAkB,WAIhB,MAXJpB,GAQiBhD,KAAKvB,KAAKwB,SAAUxB,KAAK4F,QAAQnE,UAAWzB,KAAK6F,YAC1D7F,KAAK8F,QAAU9F,KAAK8F,OAAOH,kBAC7B3F,KAAK8F,OAAOH,mBACP3F,MAGT+F,cAAe,SAAUC,GACvBhG,KAAK6F,WAfTtB,EAemCN,aAAajE,KAAK8F,OAAOF,SACxD5F,KAAK4F,QAhBTrB,EAgBgCN,aAAajE,KAAK6F,WAE9C,KAAK,GAAIlE,KAAKqE,GACRA,EAAYhE,eAAeL,KAC7B3B,KAAK4F,QAAQjE,GAAKqE,EAAYrE,GAElC3B,MAAK2F,oBAGPM,WAAY,KAMZC,GAAI,SAAUnF,EAAMb,GAClBF,KAAKiG,WAAajG,KAAKiG,cACvB,IAAIE,GAAQnG,KAAKiG,WAAWlF,GAAQf,KAAKiG,WAAWlF,MAGpD,OAFAoF,GAAMC,KAAKlG,GAEJF,MAITqG,UAAW,SAAStF,EAAMb,GACxBH,EAAEuG,SAAStG,KAAMe,EAAKyC,cAAetD,IAIvCqG,IAAK,SAAUxF,EAAMb,GACnB,GAAIiG,GAAQnG,KAAKiG,YAAcjG,KAAKiG,WAAWlF,EAC/C,IAAIoF,EACF,GAAKjG,EAGH,IAAI,GAAIyB,GAAIwE,EAAMhF,OAAQQ,KACpBwE,EAAMxE,KAAOzB,GACfiG,EAAMK,OAAO7E,EAAG,cAJb3B,MAAKiG,WAAWlF,EAO3B,OAAOf,OAITyG,YAAa,SAAS1F,EAAMb,GAC1BH,EAAE2G,cAAc1G,KAAMe,EAAKyC,gBAM7ByB,QAAS,SAAUlE,EAAM4F,EAAQC,GAC/BD,EAASA,GAAU3G,IACnB,IACIsE,GADA6B,EAAQnG,KAAKiG,YAAcjG,KAAKiG,WAAWlF,EAE/C,IAAIoF,EACF,IAAI,GAAIxE,GAAIwE,EAAMhF,OAAQQ,KAExB,GADA2C,EAAS6B,EAAMxE,GAAGlB,KAAKkG,EAAQA,EAAQC,GACnCtC,KAAW,EAAO,MAAOA,EAGjC,OAAItE,MAAK8F,OACA9F,KAAK8F,OAAOb,QAAQlE,EAAM4F,EAAQC,IAEpC,GAITC,MAAO,WAEL,GAAI,gBAAkB7G,KAAK8G,UACzB,MAAO9G,MAAK+G,SAAS,QAGvB,KAAK,GAAIpF,GAAI,EAAGA,EAAI3B,KAAKgH,OAAO7F,OAAQQ,IACtC3B,KAAKgH,OAAOrF,GAAGoF,SAAS,QAE1B/G,MAAK+G,SAAS,UAIhBE,QAAS,WAEP,GAAI,gBAAkBjH,KAAK8G,UAKzB,MAJA9G,MAAKwB,SAAS0F,WAAW,WACzBlH,KAAKwB,SAAS0F,WAAW,4BACzBlH,MAAK+G,SAAS,UAMhB,KAAK,GAAIpF,GAAI,EAAGA,EAAI3B,KAAKgH,OAAO7F,OAAQQ,IACtC3B,KAAKgH,OAAOrF,GAAGsF,SAEjBjH,MAAKwB,SAAS0F,WAAW,WACzBlH,KAAK+G,SAAS,YAGhBI,aAAc,WAEZ,MArHJ5C,GAoHiBX,SAAS,8DACf5D,KAAKoH,UAAUxG,MAAMZ,KAAMU,YAGpC2G,qBAAsB,WACpB,MAAOrH,MAAK8F,OAAOtE,SAAS8F,KAAK,IAAMtH,KAAK4F,QAAQnE,UAAY,aAAezB,KAAK4F,QAAQhB,SAAU,OCvH1G,IAAI2C,IACFvD,OAAQ,SAASwD,GACf,MAAOA,IAETC,QAAS,SAASzD,GAChB,GAAIjB,MAAMiB,GACR,KAAM,mCAAqCA,EAAS,GACtD,OAAO0D,UAAS1D,EAAQ,KAE1B2D,OAAQ,SAAS3D,GACf,GAAIjB,MAAMiB,GACR,KAAM,iCAAmCA,EAAS,GACpD,OAAO4D,YAAW5D,IAEpB6D,UAAW,SAAS7D,GAClB,GAAIM,GAASvE,EAAEiE,EACf,IAAsB,IAAlBM,EAAOnD,OACT,KAAM,uBAAyB6C,EAAS,GAC1C,OAAOM,IAETwD,UAAS,SAAS9D,GAChB,MAAkB,UAAXA,GAET+D,OAAQ,SAAS/D,GACf,MA1BJO,GA0BwBnC,iBAAiB4B,IAEvCgE,OAAQ,SAASC,GACf,GAAIC,GAAQ,EAcZ,OAXI,sBAAsBhG,KAAK+F,IAG7BC,EAAQD,EAAO7E,QAAQ,iBAAkB,MAGzC6E,EAASA,EAAO7E,QAAQ,GAAIrB,QAAO,WAAamG,EAAQ,KAAM,OAG9DD,EAAS,IAAMA,EAAS,IAEnB,GAAIlG,QAAOkG,EAAQC,KAI1BC,EAA0B,SAASnE,EAAQ7C,GAC7C,GAAIiH,GAAIpE,EAAOX,MAAM,mBACrB,KAAK+E,EACH,KAAM,iCAAmCpE,EAAS,GACpD,IAAIqE,GAASD,EAAE,GAAGE,MAAM,KAAKC,IAnD/BhE,EAmDgDR,WAC9C,IAAIsE,EAAOlH,SAAWA,EACpB,KAAM,mBAAqBkH,EAAOlH,OAAS,gBAAkBA,EAAS,aACxE,OAAOkH,IAGLG,EAAqB,SAASC,EAAiBzE,GACjD,GAAI0E,GAAYnB,EAAsBkB,GAAmB,SACzD,KAAKC,EACH,KAAM,uCAAyCD,EAAkB,GACnE,OAAOC,GAAU1E,IAGf2E,EAAgC,SAASC,EAAiB5E,EAAQ6E,GACpE,GAAIC,GAAO,KAAMC,IACjB,KAAI,GAAIC,KAAOJ,GACb,GAAII,EAAK,CACP,GAAI3G,GAAQwG,EAAkBG,EAC3B,iBAAoB3G,KACrBA,EAAQmG,EAAmBI,EAAgBI,GAAM3G,IACnD0G,EAAMC,GAAO3G,MAEbyG,GAAON,EAAmBI,EAAgBI,GAAMhF,EAGpD,QAAQ8E,EAAMC,IAKZE,EAAmB,SAASC,GAC9BnJ,EAAEoJ,QAAO,EAAMnJ,KAAMkJ,GAGvBD,GAAiB1I,WAEf6I,SAAU,SAAS/G,EAAOgH,GACxB,GAAGrJ,KAAKE,GAIN,MAFGQ,WAAUS,OAAS,IACpBkI,KAAyB7I,MAAMC,KAAKC,UAAW,EAAG,KAC7CV,KAAKE,GAAGO,KAAKT,KAAMqC,EAAOgH,EAGnC,IAAItJ,EAAEuJ,QAAQjH,GAAQ,CACpB,IAAKrC,KAAKuJ,iBACR,KAAM,cAAgBvJ,KAAKe,KAAO,mCACpC,OAAOf,MAAKuJ,iBAAiB3I,MAAMZ,KAAMU,WAEzC,GAAIV,KAAKwJ,eACP,MAAIzG,OAAMV,IACD,GACT3B,UAAU,GAAKkH,WAAWlH,UAAU,IAC7BV,KAAKwJ,eAAe5I,MAAMZ,KAAMU,WAEzC,IAAIV,KAAKyJ,eACP,MAAOzJ,MAAKyJ,eAAe7I,MAAMZ,KAAMU,UAEzC,MAAM,cAAgBV,KAAKe,KAAO,kCAMtC2I,kBAAmB,SAASC,EAAcd,GACxC,GAAI,gBAAoBc,GAGtB,MAAO5J,GAAEuJ,QAAQK,GAAgBA,GAAgBA,EAEnD,IAAIC,GAAO5J,KAAKyI,eAChB,IAAI1I,EAAEuJ,QAAQM,GAAO,CAEnB,IAAK,GADDvB,GAASF,EAAwBwB,EAAcC,EAAKzI,QAC/CQ,EAAI,EAAGA,EAAI0G,EAAOlH,OAAQQ,IACjC0G,EAAO1G,GAAK6G,EAAmBoB,EAAKjI,GAAI0G,EAAO1G,GACjD,OAAO0G,GACF,MAAItI,GAAE8J,cAAcD,GAClBjB,EAA8BiB,EAAMD,EAAcd,IAEjDL,EAAmBoB,EAAMD,KAIrClB,gBAAiB,SAEjBqB,SAAU,ECrIZ,IAAIC,GAA2B,SAAUC,EAAYC,GACnDjK,KAAK8G,UAAY,2BAGjB9G,KAAKkK,OAAS,KAEdlK,KAAKmK,KAAKH,MAAkBC,QAG1BG,GACFC,MAAO,04BAEP1C,OAAQ,4CAERF,QAAS,UAET6C,OAAQ,QAERC,SAAU,SAEVC,IAAK,GAAIzI,QACL,qWA+BK,KAGXqI,GAAYK,MAAQL,EAAYzC,OAEhCoC,EAAyBxJ,WACvB4J,KAAM,SAAUH,EAAYC,GAC1BjK,KAAKiK,QAAUA,EAEfjK,KAAKgK,WAAajK,EAAEoJ,UAAWnJ,KAAKgK,WAEpC,KAAK,GAAIjJ,KAAQiJ,GACfhK,KAAK0K,aAAa3J,EAAMiJ,EAAWjJ,GAAMb,GAAI8J,EAAWjJ,GAAM+I,SAEhEpG,QAAOiH,QAAQ1F,QAAQ,2BAIzB2F,UAAW,SAAUV,GACnB,GAAI,mBAAuBlK,MAAKiK,QAAQC,GACtC,KAAM,IAAI9F,OAAM8F,EAAS,mCAI3B,OAFAlK,MAAKkK,OAASA,EAEPlK,MAIT6K,WAAY,SAAUX,EAAQY,EAAUC,GAItC,MAHI,gBAAoBD,KACtB9K,KAAKiK,QAAQC,GAAUY,IAErB,IAASC,EACJ/K,KAAK4K,UAAUV,GAEjBlK,MAITgL,WAAY,SAAUd,EAAQnJ,EAAMkK,GAMlC,MALI,mBAAuBjL,MAAKiK,QAAQC,KACtClK,KAAKiK,QAAQC,OAEflK,KAAKiK,QAAQC,GAAQnJ,EAAKyC,eAAiByH,EAEpCjL,MAiBT0K,aAAc,SAAU3J,EAAMmK,EAAMC,GAClC,GAAInL,KAAKgK,WAAWjJ,GAClBqK,aAAa3H,KAAK,cAAgB1C,EAAO,6BACtC,IAAIyD,EAAgBxC,eAAejB,GAEtC,WADAqK,cAAa3H,KAAK,IAAM1C,EAAO,+DAGjC,OAAOf,MAAKqL,cAAczK,MAAMZ,KAAMU,YAGxC4K,gBAAiB,SAAUvK,EAAMmK,EAAMC,GACrC,MAAKnL,MAAKgK,WAAWjJ,GAIdf,KAAKqL,cAAcrL,KAAMU,YAH9B0K,aAAa3H,KAAK,cAAgB1C,EAAO,6BAClCf,KAAK0K,aAAa9J,MAAMZ,KAAMU,aAKzC6K,gBAAiB,SAAUxK,GAMzB,MALKf,MAAKgK,WAAWjJ,IACnBqK,aAAa3H,KAAK,cAAgB1C,EAAO,2BAEpCf,MAAKgK,WAAWjJ,GAEhBf,MAGTqL,cAAe,SAAUtK,EAAMyK,EAAW1B,GACpC,gBAAoB0B,KAEtBA,GACEtL,GAAIsL,EACJ1B,SAAUA,IAGT0B,EAAUpC,WACboC,EAAY,GAAIvC,GAAiBuC,IAEnCxL,KAAKgK,WAAWjJ,GAAQyK,CAExB,KAAK,GAAItB,KAAUsB,GAAUV,aAC3B9K,KAAKgL,WAAWd,EAAQnJ,EAAMyK,EAAUV,SAASZ,GAEnD,OAAOlK,OAGTyL,gBAAiB,SAAUC,GACzB,GAAIT,EAGJ,IAAI,SAAWS,EAAW3K,KAAM,CAC9B,GAAI4K,GAAe3L,KAAKiK,QAAQjK,KAAKkK,QAAQwB,EAAW3K,SACxDkK,GAAUU,EAAaD,EAAW/B,kBAElCsB,GAAUjL,KAAK4L,cAAc5L,KAAKiK,QAAQjK,KAAKkK,QAAQwB,EAAW3K,MAAO2K,EAAW/B,aAEtF,OAAOsB,IAAWjL,KAAKiK,QAAQjK,KAAKkK,QAAQ2B,gBAAkB7L,KAAKiK,QAAQ6B,GAAGD,gBAIhFD,cAAe,SAAU5H,EAAQ+H,GAC/B,GAAI,gBAAoBA,GAAY,CAClC,IAAK,GAAIpK,KAAKoK,GACZ/H,EAAShE,KAAK4L,cAAc5H,EAAQ+H,EAAWpK,GAEjD,OAAOqC,GAGT,MAAO,gBAAoBA,GAASA,EAAOZ,QAAQ,GAAIrB,QAAO,KAAM,KAAMgK,GAAc,IAU1F/B,YACEgC,UACEvC,eAAgB,SAASpH,GACvB,MAAO,KAAKH,KAAKG,IAEnByH,SAAU,GAEZmC,UACE1C,iBAAkB,SAASlB,GACzB,MAAOA,GAAOlH,OAAS,GAEzBsI,eAAgB,SAASpH,GACvB,MAAO,KAAKH,KAAKG,IAEnByH,SAAU,KAEZF,MACEH,eAAgB,SAASpH,EAAOuH,GAC9B,GAAI9H,GAAQsI,EAAYR,EACxB,KAAK9H,EACH,KAAM,IAAIsC,OAAM,mBAAqBwF,EAAO,qBAC9C,OAAO9H,GAAMI,KAAKG,IAEpByH,SAAU,KAEZoC,SACEzC,eAAgB,SAASpH,EAAO2F,GAC9B,MAAOA,GAAO9F,KAAKG,IAErBoG,gBAAiB,SACjBqB,SAAU,IAEZqC,WACE1C,eAAgB,SAAUpH,EAAO+J,GAC/B,MAAO/J,GAAMlB,QAAUiL,GAEzB3D,gBAAiB,UACjBqB,SAAU,IAEZuC,WACE5C,eAAgB,SAAUpH,EAAO+J,GAC/B,MAAO/J,GAAMlB,QAAUiL,GAEzB3D,gBAAiB,UACjBqB,SAAU,IAEZ3I,QACEsI,eAAgB,SAAUpH,EAAOiK,EAAKC,GACpC,MAAOlK,GAAMlB,QAAUmL,GAAOjK,EAAMlB,QAAUoL,GAEhD9D,iBAAkB,UAAW,WAC7BqB,SAAU,IAEZ0C,UACEjD,iBAAkB,SAAUlB,EAAQ+D,GAClC,MAAO/D,GAAOlH,QAAUiL,GAE1B3D,gBAAiB,UACjBqB,SAAU,IAEZ2C,UACElD,iBAAkB,SAAUlB,EAAQ+D,GAClC,MAAO/D,GAAOlH,QAAUiL,GAE1B3D,gBAAiB,UACjBqB,SAAU,IAEZ4C,OACEnD,iBAAkB,SAAUlB,EAAQiE,EAAKC,GACvC,MAAOlE,GAAOlH,QAAUmL,GAAOjE,EAAOlH,QAAUoL,GAElD9D,iBAAkB,UAAW,WAC7BqB,SAAU,IAEZwC,KACE9C,eAAgB,SAAUnH,EAAO+J,GAC/B,MAAO/J,IAAS+J,GAElB3D,gBAAiB,SACjBqB,SAAU,IAEZyC,KACE/C,eAAgB,SAAUnH,EAAO+J,GAC/B,MAAgBA,IAAT/J,GAEToG,gBAAiB,SACjBqB,SAAU,IAEZW,OACEjB,eAAgB,SAAUnH,EAAOiK,EAAKC,GACpC,MAAOlK,IAASiK,GAAgBC,GAATlK,GAEzBoG,iBAAkB,SAAU,UAC5BqB,SAAU,IAEZ6C,SACElD,eAAgB,SAAUpH,EAAOuK,GAC/B,GAAIC,GAAa9M,EAAE6M,EACnB,OAAIC,GAAW1L,OACNkB,IAAUwK,EAAWC,MAErBzK,IAAUuK,GAErB9C,SAAU,MCxShB,IAAIiD,GAAY,SAAUnH,GACxB5F,KAAK8G,UAAY,YAGnBiG,GAAUxM,WACRyM,OAAQ,WACN,GAAIC,GAAOjN,IAUX,OATA0D,QAAOiH,QACNzE,GAAG,YAAmB,WAAc+G,EAAKC,UAAWlN,QACpDkG,GAAG,aAAmB,WAAc+G,EAAKE,WAAWnN,QACpDkG,GAAG,kBAAmB,WAAc+G,EAAKG,OAAWpN,QACpDkG,GAAG,iBAAmB,WAAc+G,EAAKjI,MAAWhF,QACpDkG,GAAG,cAAmB,WAAc+G,EAAKpG,MAAW7G,QACpDkG,GAAG,eAAmB,WAAc+G,EAAKhG,QAAWjH,QACpDkG,GAAG,gBAAmB,WAAc+G,EAAKhG,QAAWjH,QAE9CA,MAGToN,OAAQ,SAAUC,GAEhB,GAAI,mBAAuBA,GAAcC,MAAO,IAAUD,EAAcC,IAAIC,OAA5E,CAIA,GAAIC,GAAOxN,KAAKyN,MAAMJ,EAAcK,iBAAkBL,EAAcC,IAAIK,qBAGxEN,GAAcC,IAAIK,qBAAuBN,EAAcK,iBAGvDL,EAAcC,IAAIM,eAAgB,EAGlC5N,KAAK6N,kBAAkBR,GAGvBrN,KAAK8N,qBAAqBT,EAAeG,GAGzCxN,KAAK+N,kBAAkBV,IAGlBG,EAAKQ,KAAK7M,QAAUqM,EAAKS,MAAM9M,UAAW,IAASkM,EAAcC,IAAIY,YACxElO,KAAKmO,0BAA0Bd,KAInCe,kBAAmB,SAAUf,GAE3B,IAAI,IAASA,EAAcK,iBACzB,QAIF,KAAK,GAFD5C,MAEKnJ,EAAI,EAAGA,EAAI0L,EAAcK,iBAAiBvM,OAAQQ,IACzDmJ,EAAS1E,KAAKpG,KAAKqO,iBAAiBhB,EAAeA,EAAcK,iBAAiB/L,GAAG2M,QAEvF,OAAOxD,IAGT+C,kBAAmB,SAAUR,GACvBA,EAAckB,kBAAoBlB,EAAcmB,oBAAqB,IAASnB,EAAcK,iBAC9F1N,KAAKyO,cAAcpB,GACZA,EAAcK,iBAAiBvM,OAAS,EAC/CnB,KAAK0O,YAAYrB,GAEjBrN,KAAK2O,YAAYtB,IAGrBS,qBAAsB,SAAUT,EAAeG,GAC7C,GAAI,mBAAuBH,GAAczH,QAAQgJ,uBAAjD,CAIA,GAAI,mBAAuBvB,GAAczH,QAAQiJ,aAC/C,MAAKrB,GAAKS,MAAM9M,QAAUqM,EAAKQ,KAAK7M,QAClCnB,KAAK8O,oBAAoBzB,GAErB,IAAMA,EAAcC,IAAIyB,eAAezH,KAAK,iCAAiCnG,QAC/EkM,EAAcC,IAAIyB,eACfC,OACCjP,EAAEsN,EAAczH,QAAQJ,eACvByJ,SAAS,iCAGT5B,EAAcC,IAAIyB,eACtBE,SAAS,UACT3H,KAAK,iCACL4H,KAAK7B,EAAczH,QAAQiJ,eAGzBxB,EAAcC,IAAIyB,eACtBI,YAAY,UACZ7H,KAAK,iCACL8H,QAIL,KAAK,GAAIzN,GAAI,EAAGA,EAAI6L,EAAK6B,QAAQlO,OAAQQ,IACvC3B,KAAKsP,YAAYjC,EAAeG,EAAK6B,QAAQ1N,GAAG2M,OAAOvN,MAAM,EAE/D,KAAKY,EAAI,EAAGA,EAAI6L,EAAKS,MAAM9M,OAAQQ,IACjC3B,KAAKuP,SAASlC,EAAeG,EAAKS,MAAMtM,GAAG2M,OAAOvN,KAAMyO,OAAWhC,EAAKS,MAAMtM,GAAG2M,QAAQ,EAE3F,KAAK3M,EAAI,EAAGA,EAAI6L,EAAKQ,KAAK7M,OAAQQ,IAChC3B,KAAKyP,YAAYpC,EAAeG,EAAKQ,KAAKrM,GAAG2M,OAAOvN,KAAMyO,OAAWhC,EAAKQ,KAAKrM,GAAG2M,QAAQ,KAK9FiB,SAAU,SAAUlC,EAAetM,EAAMkK,EAASqD,EAAQoB,GACxD1P,KAAK8O,oBAAoBzB,GACzBA,EAAcC,IAAIyB,eACfE,SAAS,UACTD,OACCjP,EAAEsN,EAAczH,QAAQJ,eACvByJ,SAAS,WAAalO,GACtBmO,KAAKjE,GAAWjL,KAAKqO,iBAAiBhB,EAAeiB,MAGtD,IAASoB,GACX1P,KAAK0O,YAAYrB,IAIrBoC,YAAa,SAAUpC,EAAetM,EAAMkK,EAASqD,EAAQoB,GAC3DrC,EAAcC,IAAIyB,eACfE,SAAS,UACT3H,KAAK,YAAcvG,GACnBmO,KAAKjE,GAAWjL,KAAKqO,iBAAiBhB,EAAeiB,KAEpD,IAASoB,GACX1P,KAAK0O,YAAYrB,IAIrBiC,YAAa,SAAUjC,EAAetM,EAAM2O,GAC1CrC,EAAcC,IAAIyB,eACfI,YAAY,UACZ7H,KAAK,YAAcvG,GACnBqO,UAIC,IAASM,GACX1P,KAAK6N,kBAAkBR,IAG3BrI,MAAO,SAAU2K,GAGf,GAFAA,EAAaC,cAAgB,MAEzB,IAASD,EAAajC,kBAAoB,SAAWiC,EAAa/J,QAAQZ,MAC5E,MAAO,KAET,KAAK,GAAIrD,GAAI,EAAGA,EAAIgO,EAAa3I,OAAO7F,OAAQQ,IAAK,CACnD,GAAIkO,GAAQF,EAAa3I,OAAOrF,EAChC,KAAI,IAASkO,EAAMnC,kBAAoBmC,EAAMnC,iBAAiBvM,OAAS,GAAK,mBAAuB0O,GAAMjK,QAAQkK,UAC/GH,EAAaC,cAAgBC,EAAMrO,SAC/B,UAAYmO,EAAa/J,QAAQZ,OACnC,MAIN,MAAI,QAAS2K,EAAaC,cACjB,KAEFD,EAAaC,cAAc5K,SAGpCqJ,iBAAkB,SAAUhB,EAAe3B,GACzC,GAAIqE,GAA+BrE,EAAW3K,KAAO,SAErD,OAAI,mBAAuBsM,GAAczH,QAAQmK,GACxCrM,OAAOiH,QAAQiB,cAAcyB,EAAczH,QAAQmK,GAA+BrE,EAAW/B,cAE/FjG,OAAOiH,QAAQc,gBAAgBC,IAGxC+B,MAAO,SAAUuC,EAAWC,EAAWC,GAKrC,IAAK,GAHHjC,MACAD,KAEOrM,EAAI,EAAGA,EAAIqO,EAAU7O,OAAQQ,IAAK,CAGzC,IAAK,GAFDwO,IAAQ,EAEHC,EAAI,EAAGA,EAAIH,EAAU9O,OAAQiP,IACpC,GAAIJ,EAAUrO,GAAG2M,OAAOvN,OAASkP,EAAUG,GAAG9B,OAAOvN,KAAM,CACzDoP,GAAQ,CACR,OAGAA,EACFnC,EAAK5H,KAAK4J,EAAUrO,IAEpBsM,EAAM7H,KAAK4J,EAAUrO,IAGzB,OACEqM,KAAMA,EACNC,MAAOA,EACPoB,QAAUa,KAAOlQ,KAAKyN,MAAMwC,EAAWD,GAAW,GAAM/B,QAI5Df,UAAW,SAAUyC,GACnBA,EAAanO,SAAS0E,GAAG,kBAAkB,EAAOnG,EAAEsQ,MAAMV,EAAaW,iBAAkBX,KAGrF,IAAUA,EAAa/J,QAAQd,WAGnC6K,EAAanO,SAASD,KAAK,aAAc,KAG3C4L,WAAY,SAAUE,GACpB,GAAIC,IAAQC,QAAQ,IAGhB,IAAUF,EAAczH,QAAQd,YAGpCwI,EAAIC,QAAS,EAGbF,EAAc7L,SAASD,KAAK8L,EAAczH,QAAQnE,UAAY,KAAM4L,EAAckD,QAIlFjD,EAAIkD,mBAAqBxQ,KAAKyQ,oBAAoBpD,GAGlDC,EAAIoD,gBAAkB,eAAiBrD,EAAczH,QAAQhB,SAAW,YAAcyI,EAAczH,QAAQhB,SAAWyI,EAAckD,QACrIjD,EAAIyB,eAAiBhP,EAAEsN,EAAczH,QAAQL,eAAehE,KAAK,KAAM+L,EAAIoD,iBAG3EpD,EAAIK,wBACJL,EAAIM,eAAgB,EACpBN,EAAIqD,8BAA+B,EAGnCtD,EAAcC,IAAMA,EAGpBtN,KAAK+N,kBAAkBV,KAIzBoD,oBAAqB,SAAUpD,GAE7B,GAAI,gBAAoBA,GAAczH,QAAQR,cAAgBrF,EAAEsN,EAAczH,QAAQR,cAAcjE,OAClG,MAAOpB,GAAEsN,EAAczH,QAAQR,aAGjC,IAAIwL,GAAWvD,EAAczH,QAAQR,aAAaiI,EAGlD,OAAI,mBAAuBuD,IAAYA,EAASzP,OACvCyP,GAGJvD,EAAczH,QAAQhB,UAAYyI,EAAc7L,SAASgB,GAAG,UACxD6K,EAAc7L,SAGhB6L,EAAc7L,SAASsE,UAGhCgJ,oBAAqB,SAAUzB,GAC7B,GAAIwD,EAGJ,IAAI,IAAMxD,EAAcC,IAAIyB,eAAejJ,SAAS3E,OAClD,MAAOkM,GAAcC,IAAIyB,eAAejJ,QAE1C,IAAI,gBAAoBuH,GAAczH,QAAQN,gBAAiB,CAC7D,GAAIvF,EAAEsN,EAAczH,QAAQN,iBAAiBnE,OAC3C,MAAOpB,GAAEsN,EAAczH,QAAQN,iBAAiB0J,OAAO3B,EAAcC,IAAIyB,eAxRjFxK,GA0RqBd,KAAK,yBAA2B4J,EAAczH,QAAQN,gBAAkB,+BAEhF,kBAAsB+H,GAAczH,QAAQN,kBACnDuL,EAAmBxD,EAAczH,QAAQN,gBAAgB+H,GAE3D,IAAI,mBAAuBwD,IAAoBA,EAAiB1P,OAC9D,MAAO0P,GAAiB7B,OAAO3B,EAAcC,IAAIyB,eAEnD,IAAI+B,GAAQzD,EAAc7L,QAG1B,OAFI6L,GAAczH,QAAQhB,WACxBkM,EAAQA,EAAMhL,UACTgL,EAAMC,MAAM1D,EAAcC,IAAIyB,iBAGvChB,kBAAmB,SAAUV,GAC3B,GAAI2D,GAAU3D,EAAc7L,QAQ5B,IAPI6L,EAAczH,QAAQhB,WACxBoM,EAAUjR,EAAE,IAAMsN,EAAczH,QAAQnE,UAAY,aAAe4L,EAAczH,QAAQhB,SAAW,OAGtGoM,EAAQzK,IAAI,aAGR,IAAU8G,EAAczH,QAAQX,QAApC,CAGA,GAAIgM,GAAW5D,EAAczH,QAAQX,QAAQ7B,QAAQ,QAAU,IAAIA,QAAQ,QAAU,GAEjF,MAAO6N,GAIXD,EAAQ9K,GACN+K,EAAS3I,MAAM,KAAK4I,KAAK,aAAe,WACxCnR,EAAEsQ,MAAM,kBAAsBhD,GAAc8D,cAAgB9D,EAAc8D,cAAgBnR,KAAKmR,cAAe9D,MAIlH8D,cAAe,SAAUC,GAInB,GAAIrP,QAAO,OAAOG,KAAKkP,EAAMxH,QAC1B5J,KAAKsN,IAAIqD,8BAAgC3Q,KAAKqR,WAAWlQ,QAAUnB,KAAK4F,QAAQb,sBAGvF/E,KAAKsN,IAAIM,eAAgB,EACzB5N,KAAKoJ,aAGP+E,0BAA2B,SAAUd,GAWnC,MAVAA,GAAcC,IAAIY,YAAa,EAG3Bb,EAAczH,QAAQhB,UACxB7E,EAAE,IAAMsN,EAAczH,QAAQnE,UAAY,aAAe4L,EAAczH,QAAQhB,SAAW,MAAM0M,KAAK,WACnG,MAAK,IAAIvP,QAAO,SAAU,KAAKG,KAAKnC,EAAEC,MAAMF,UAAU8F,QAAQX,SAAW,IAAzE,OACSlF,EAAEC,MAAMkG,GAAG,4BAA4B,EAAOnG,EAAEsQ,MAAMhD,EAAcjE,SAAUiE,MAIvFA,EAAc7L,SAASgB,GAAG,YACvB,GAAIT,QAAO,SAAU,KAAKG,KAAKmL,EAAczH,QAAQX,SAAW,IAC5DoI,EAAc7L,SAAS0E,GAAG,4BAA4B,EAAOnG,EAAEsQ,MAAMhD,EAAcjE,SAAUiE,IAGnG,GAAItL,QAAO,QAAS,KAAKG,KAAKmL,EAAczH,QAAQX,SAAW,IAApE,OACSoI,EAAc7L,SAAS0E,GAAG,2BAA2B,EAAOnG,EAAEsQ,MAAMhD,EAAcjE,SAAUiE,KAGvGxG,MAAO,SAAU0K,GAEfvR,KAAK+N,kBAAkBwD,GACvBA,EAAgB/P,SAAS+E,IAAI,sBAGzB,mBAAuBgL,GAAgBjE,KAGvC,gBAAkBiE,EAAgBzK,YAItCyK,EAAgBjE,IAAIyB,eACjBI,YAAY,UACZqC,WACApC,SAGHpP,KAAK2O,YAAY4C,GAGjBA,EAAgBjE,IAAIM,eAAgB,EACpC2D,EAAgBjE,IAAIK,wBACpB4D,EAAgBjE,IAAIqD,8BAA+B,EACnDY,EAAgBjE,IAAIY,YAAa,IAGnCjH,QAAS,SAAUsK,GACjBvR,KAAK6G,MAAM0K,GAEP,gBAAkBA,EAAgBzK,YAGlC,mBAAuByK,GAAgBjE,KACzCiE,EAAgBjE,IAAIyB,eAAeK,eAE9BmC,GAAgBjE,MAGzBmB,cAAe,SAAUpB,GACvBA,EAAcC,IAAIqD,8BAA+B,EACjDtD,EAAcC,IAAIkD,mBAAmBrB,YAAY9B,EAAczH,QAAQV,YAAY+J,SAAS5B,EAAczH,QAAQT,eAEpHuJ,YAAa,SAAUrB,GACrBA,EAAcC,IAAIqD,8BAA+B,EACjDtD,EAAcC,IAAIkD,mBAAmBrB,YAAY9B,EAAczH,QAAQT,cAAc8J,SAAS5B,EAAczH,QAAQV,aAEtHyJ,YAAa,SAAUtB,GACrBA,EAAcC,IAAIkD,mBAAmBrB,YAAY9B,EAAczH,QAAQT,cAAcgK,YAAY9B,EAAczH,QAAQV,aC9Y3H,IAAIuM,GAAc,SAAUC,EAAS7L,EAAYD,GAC/C5F,KAAK8G,UAAY,cACjB9G,KAAKuQ,OALPhM,EAK6B1B,aAE3B7C,KAAKwB,SAAWzB,EAAE2R,GAClB1R,KAAK6F,WAAaA,EAClB7F,KAAK4F,QAAUA,EACf5F,KAAK8F,OAASpC,OAAOiH,QAErB3K,KAAKgH,UACLhH,KAAK0N,iBAAmB,MAb1BiE,GAgBsBC,QAAS,KAAMC,UAAU,EAAMC,UAAU,EAE/DL,GAAYlR,WACV+P,iBAAkB,SAAUc,GAC1B,GAAInE,GAAOjN,IAGX,KAAI,IAASoR,EAAMtR,QAYnB,MAPAsR,GAAMW,2BACNX,EAAMY,iBAENhS,KAAKiS,aAAazC,OAAWA,OAAW4B,GACrCc,KAAK,WAAajF,EAAKkF,YACvBC,OAAO,WAAanF,EAAKoF,cAAgB,OAErCrS,MAMTmS,QAAS,YACH,IAAUnS,KAAK+G,SAAS,YAE5B/G,KAAKwB,SAAS8F,KAAK,oCAAoC8H,SACnDpP,KAAKqS,eACPtS,EAAE,kEACDwB,KAAK,OAAQvB,KAAKqS,cAActR,MAChCQ,KAAK,QAASvB,KAAKqS,cAAchQ,OACjCiQ,SAAStS,KAAKwB,UAEjBxB,KAAKwB,SAASyD,QAAQlF,EAAEoJ,OAAOpJ,EAAEwS,MAAM,WAAazS,SAAS,OAQ/DsJ,SAAU,SAAUvE,EAAO2N,EAAOpB,GAChC,MA5DJO,GA4D0B3R,KAAKiS,aAAapN,EAAO2N,EAAOpB,GAAOqB,UAG/DR,aAAc,SAAUpN,EAAO2N,EAAOpB,GACpC,GAAInE,GAAOjN,IACXA,MAAK0S,YAActB,EACnBpR,KAAK0N,kBAAmB,EAGxB1N,KAAK+G,SAAS,YAGd/G,KAAK2S,gBAEL,IAAIC,GAAW5S,KAAK6S,iCAAiC,WACnD,MAAO9S,GAAEwI,IAAIvI,KAAKgH,OAAQ,SAAS6I,GAEjC,OAAKhL,GAASoI,EAAK6F,gBAAgBjD,EAAOhL,GACjCgL,EAAMoC,aAAaO,GAD5B,UAIJ,OAAOzS,GAAEgT,KAAKnS,MAAMb,EAAG6S,GACpBV,KAAO,WAAajF,EAAKlG,SAAS,aAClCiM,KAAO,WAAa/F,EAAKS,kBAAmB,EAAAT,EAAYlG,SAAS,WACjEqL,OAAO,WAAanF,EAAKlG,SAAS,gBAOvCkM,QAAS,SAAUpO,EAAO2N,GACxB,MA5FJb,GA4F0B3R,KAAKoH,UAAUvC,EAAO2N,GAAOC,UAMrDrL,UAAW,SAAUvC,EAAO2N,GAC1B,GAAIvF,GAAOjN,IACXA,MAAK2S,gBAEL,IAAIC,GAAW5S,KAAK6S,iCAAiC,WACnD,MAAO9S,GAAEwI,IAAIvI,KAAKgH,OAAQ,SAAS6I,GAEjC,OAAKhL,GAASoI,EAAK6F,gBAAgBjD,EAAOhL,GACjCgL,EAAMzI,UAAUoL,GADzB,UAIJ,OAAOzS,GAAEgT,KAAKnS,MAAMb,EAAG6S,IAGzBE,gBAAiB,SAAUjD,EAAOhL,GAChC,MAAG9E,GAAEuJ,QAAQuG,EAAMjK,QAAQf,OAClB,KAAO9E,EAAEmT,QAAQrO,EAAOgL,EAAMjK,QAAQf,OACxCgL,EAAMjK,QAAQf,QAAUA,GAGjC8N,eAAgB,WACd,MAAO3S,MAAK2F,mBAAmBwN,eAGjCA,YAAa,WACX,GAAIC,GAAOpT,KACTqT,EAAYrT,KAAKgH,MAwBnB,OAtBAhH,MAAKgH,UACLhH,KAAKsT,oBAELtT,KAAK6S,iCAAiC,WACpC7S,KAAKwB,SACJ8F,KAAKtH,KAAK4F,QAAQnB,QAClB8O,IAAIvT,KAAK4F,QAAQlB,UACjB4M,KAAK,WACJ,GAAIjE,GAAgB,GAAI1C,SAAQ6I,QAAQxT,QAAUoT,EAG7C,kBAAmB/F,EAAcvG,WAAa,yBAA2BuG,EAAcvG,YAAe,IAASuG,EAAczH,QAAQlB,UACpI,mBAAuB0O,GAAKE,iBAAiBjG,EAAcvG,UAAY,IAAMuG,EAAckD,UAC7F6C,EAAKE,iBAAiBjG,EAAcvG,UAAY,IAAMuG,EAAckD,QAAUlD,EAC9E+F,EAAKpM,OAAOZ,KAAKiH,MAIvBtN,EAAEsT,GAAWE,IAAIH,EAAKpM,QAAQsK,KAAK,WACjCtR,KAAK+G,SAAS,aAGX/G,MAUT6S,iCAAkC,SAAU3S,GAC1C,GAAIuT,GAAsBzT,KAAK2F,gBAC/B3F,MAAK2F,iBAAmB,WAAa,MAAO3F,MAC5C,IAAIsE,GAASpE,EAAGO,KAAKT,KAErB,OADAA,MAAK2F,iBAAmB8N,EACjBnP,GAMTyC,SAAU,SAAUjG,GAClB,MAAOd,MAAKiF,QAAQ,QAAUnE,ICtKlC,IAAI4S,GAAoB,SAAUC,EAAc5S,EAAM4I,EAAcG,EAAU8J,GAC5E,IAAK,GAAI7R,QAAO,gBAAgBG,KAAKyR,EAAa7M,WAChD,KAAM,IAAI1C,OAAM,yDAElB,IAAIyP,GAAgBnQ,OAAOiH,QAAQmJ,mBAAmB9J,WAAWjJ,GAC7DyK,EAAY,GAAIvC,GAAiB4K,EAErC9T,GAAEoJ,OAAOnJ,MACPwL,UAAWA,EACXzK,KAAMA,EACN4I,aAAcA,EACdG,SAAUA,GAAY6J,EAAa/N,QAAQ7E,EAAO,aAAeyK,EAAU1B,SAC3E8J,iBAAiB,IAASA,IAE5B5T,KAAK+T,mBAAmBJ,EAAa/N,UAGnCoO,EAAa,SAAS7Q,GACxB,GAAI8Q,GAAM9Q,EAAI,GAAGI,aACjB,OAAO0Q,GAAM9Q,EAAI3C,MAAM,GAGzBkT,GAAkBnT,WAChB6I,SAAU,SAAS/G,EAAO6R,GACxB,GAAI7T,GAAOL,KAAKmU,gBAAgB3T,MAAM,EAGtC,OAFAH,GAAKM,QAAQ0B,GACbhC,EAAK+F,KAAK8N,GACHlU,KAAKwL,UAAUpC,SAASxI,MAAMZ,KAAKwL,UAAWnL,IAGvD0T,mBAAoB,SAASnO,GAC3B,GAAIqH,GAAOjN,IACXA,MAAKmU,gBAAkBnU,KAAKwL,UAAU9B,kBAAkB1J,KAAK2J,aAAc,SAASX,GAClF,MAAOpD,GAAQqH,EAAKlM,KAAOiT,EAAWhL,OCjC5C,IAAI3D,GAAe,SAAUwK,EAAOhK,EAAYD,EAASwO,GACvDpU,KAAK8G,UAAY,eACjB9G,KAAKuQ,OANPhM,EAM6B1B,aAE3B7C,KAAKwB,SAAWzB,EAAE8P,GAGd,mBAAuBuE,KACzBpU,KAAK8F,OAASsO,GAGhBpU,KAAK4F,QAAUA,EACf5F,KAAK6F,WAAaA,EAGlB7F,KAAKqU,eACLrU,KAAKsU,qBACLtU,KAAK0N,oBAGL1N,KAAKuU,oBAxBPC,GA2BsB5C,QAAS,KAAMC,UAAU,EAAMC,UAAU,EAE/DzM,GAAa9E,WAKX6I,SAAU,SAAUoJ,GAClB,GAAIiC,GAAUzU,KAAKiS,aAAaO,EAChC,QAAQiC,EAAQhC,SACd,IAAK,UAAW,MAAO,KACvB,KAAK,WAAY,OAAO,CACxB,KAAK,WAAY,MAAOzS,MAAK0N,mBAMjCuE,aAAc,SAAUO,GACtB,GAAIvF,GAAOjN,IAOX,OALAA,MAAKqC,MAAQrC,KAAKqR,WAGlBrR,KAAK+G,SAAS,YAEP/G,KAAKoH,UAAUoL,EAAOxS,KAAKqC,OAC/B6P,KAAK,WAAejF,EAAKlG,SAAS,aAClCiM,KAAK,WAAe/F,EAAKlG,SAAS,WAClCqL,OAAO,WAAanF,EAAKlG,SAAS,gBAGvCwH,eAAgB,WACd,MAAO,KAAMvO,KAAKqU,YAAYlT,QAIhCqN,gBAAiB,SAAUnM,GAMzB,MALI,mBAAuBA,KACzBA,EAAQrC,KAAKqR,YAIVhP,EAAMlB,QAAWnB,KAAK0U,eAAiB,mBAAuB1U,MAAK4F,QAAQ+O,iBAGzE,GAFE,GASX1B,QAAS,SAAUT,EAAOnQ,GACxB,MAjFJmS,GAiFyBxU,KAAKoH,UAAUoL,EAAOnQ,GAAOoQ,UAGpDrL,UAAW,SAAUoL,EAAOnQ,GAM1B,GAJArC,KAAK4U,qBACL5U,KAAK0N,kBAAmB,GAGnB1N,KAAKuO,iBACR,MAAOxO,GAAEgT,MAMX,KAHI,mBAAuB1Q,IAAS,OAASA,KAC3CA,EAAQrC,KAAKqR,aAEVrR,KAAKwO,gBAAgBnM,KAAU,IAASmQ,EAC3C,MAAOzS,GAAEgT,MAEX,IAAI8B,GAAqB7U,KAAK8U,yBAC1BlC,KACA3F,EAAOjN,IAWX,OAVAD,GAAEuR,KAAKuD,EAAoB,SAASE,EAAGV,GAGrC,GAAII,GAAU1U,EAAEgT,KAAKnS,MAAMb,EACzBA,EAAEwI,IAAI8L,EAAatU,EAAEsQ,MAAMpD,EAAM,sBAAuB5K,IAG1D,OADAuQ,GAASxM,KAAKqO,GACU,aAApBA,EAAQhC,SACH,EADT,SAGK1S,EAAEgT,KAAKnS,MAAMb,EAAG6S,IAIzBoC,oBAAqB,SAAS3S,EAAOqJ,GACnC,GAAIuB,GAAOjN,KACPsE,EAASoH,EAAWtC,SAAS/G,EAAOrC,KAKxC,QAHI,IAAUsE,IACZA,EAASvE,EAAEkV,WAAWC,UAEjBnV,EAAEgT,KAAKzO,GAAQ0O,KAAK,YACrB,IAAS/F,EAAKS,mBAChBT,EAAKS,qBACPT,EAAKS,iBAAiBtH,MAAMkI,OAAQ5C,OAKxC2F,SAAU,WACR,GAAIhP,EAWJ,OAPEA,GADE,kBAAsBrC,MAAK4F,QAAQvD,MAC7BrC,KAAK4F,QAAQvD,MAAMrC,MACpB,mBAAuBA,MAAK4F,QAAQvD,MACnCrC,KAAK4F,QAAQvD,MAEbrC,KAAKwB,SAASsL,MAGpB,mBAAuBzK,IAAS,OAASA,EACpC,GAEFrC,KAAKmV,kBAAkB9S,IAKhCuS,mBAAoB,WAClB,MAAO5U,MAAK2F,mBAAmB4O,oBAYjCa,cAAe,SAAUrU,EAAM4I,EAAcG,EAAU8J,GAErD,GAAIlQ,OAAOiH,QAAQmJ,mBAAmB9J,WAAWjJ,GAAO,CACtD,GAAI2K,GAAa,GAAIgI,GAAkB1T,KAAMe,EAAM4I,EAAcG,EAAU8J,EAGvE,eAAgB5T,KAAKsU,kBAAkB5I,EAAW3K,OACpDf,KAAKqV,iBAAiB3J,EAAW3K,MAEnCf,KAAKqU,YAAYjO,KAAKsF,GACtB1L,KAAKsU,kBAAkB5I,EAAW3K,MAAQ2K,EAG5C,MAAO1L,OAITqV,iBAAkB,SAAUtU,GAC1B,IAAK,GAAIY,GAAI,EAAGA,EAAI3B,KAAKqU,YAAYlT,OAAQQ,IAC3C,GAAIZ,IAASf,KAAKqU,YAAY1S,GAAGZ,KAAM,CACrCf,KAAKqU,YAAY7N,OAAO7E,EAAG,EAC3B,OAGJ,aADO3B,MAAKsU,kBAAkBvT,GACvBf,MAITsV,iBAAkB,SAAUvU,EAAMgL,EAAYjC,GAC5C,MAAO9J,MAAKqV,iBAAiBtU,GAC1BqU,cAAcrU,EAAMgL,EAAYjC,IAOrCyK,iBAAkB,WAIhB,IAAK,GAHDF,MAAkBC,KAGb3S,EAAI,EAAGA,EAAI3B,KAAKqU,YAAYlT,OAAQQ,KACvC,IAAU3B,KAAKqU,YAAY1S,GAAGiS,kBAChCS,EAAYjO,KAAKpG,KAAKqU,YAAY1S,IAClC2S,EAAkBtU,KAAKqU,YAAY1S,GAAGZ,MAAQf,KAAKqU,YAAY1S,GAGnE3B,MAAKqU,YAAcA,EACnBrU,KAAKsU,kBAAoBA,CAGzB,KAAK,GAAIvT,KAAQf,MAAK4F,QACpB5F,KAAKoV,cAAcrU,EAAMf,KAAK4F,QAAQ7E,GAAOyO,QAAW,EAG1D,OAAOxP,MAAKuV,yBAKdA,sBAAuB,YAEjBvV,KAAKwB,SAASgU,SAAS,aAAexV,KAAKwB,SAASD,KAAK,cAC3DvB,KAAKoV,cAAc,YAAY,EAAM5F,QAAW,GAG9C,gBAAoBxP,MAAKwB,SAASD,KAAK,YACzCvB,KAAKoV,cAAc,UAAWpV,KAAKwB,SAASD,KAAK,WAAYiO,QAAW,GAGtE,mBAAuBxP,MAAKwB,SAASD,KAAK,QAAU,mBAAuBvB,MAAKwB,SAASD,KAAK,OAChGvB,KAAKoV,cAAc,SAAUpV,KAAKwB,SAASD,KAAK,OAAQvB,KAAKwB,SAASD,KAAK,QAASiO,QAAW,GAGxF,mBAAuBxP,MAAKwB,SAASD,KAAK,OACjDvB,KAAKoV,cAAc,MAAOpV,KAAKwB,SAASD,KAAK,OAAQiO,QAAW,GAGzD,mBAAuBxP,MAAKwB,SAASD,KAAK,QACjDvB,KAAKoV,cAAc,MAAOpV,KAAKwB,SAASD,KAAK,OAAQiO,QAAW,GAI9D,mBAAuBxP,MAAKwB,SAASD,KAAK,cAAgB,mBAAuBvB,MAAKwB,SAASD,KAAK,aACtGvB,KAAKoV,cAAc,UAAWpV,KAAKwB,SAASD,KAAK,aAAcvB,KAAKwB,SAASD,KAAK,cAAeiO,QAAW,GAGrG,mBAAuBxP,MAAKwB,SAASD,KAAK,aACjDvB,KAAKoV,cAAc,YAAapV,KAAKwB,SAASD,KAAK,aAAciO,QAAW,GAGrE,mBAAuBxP,MAAKwB,SAASD,KAAK,cACjDvB,KAAKoV,cAAc,YAAapV,KAAKwB,SAASD,KAAK,aAAciO,QAAW,EAI9E,IAAI5F,GAAO5J,KAAKwB,SAASD,KAAK,OAE9B,OAAI,mBAAuBqI,GAClB5J,KAGL,WAAa4J,EACX,mBAAwB5J,MAAKwB,SAASD,KAAK,SAAa,IAAMqG,WAAW5H,KAAKwB,SAASD,KAAK,SAAW,EAClGvB,KAAKoV,cAAc,OAAQ,UAAW5F,QAAW,GAEjDxP,KAAKoV,cAAc,OAAQ,SAAU5F,QAAW,GAGhD,uBAAuBtN,KAAK0H,GAC9B5J,KAAKoV,cAAc,OAAQxL,EAAM4F,QAAW,GAE9CxP,MAKT0U,YAAa,WACX,MAAI,mBAAuB1U,MAAKsU,kBAAkBrI,UACzC,GAEF,IAAUjM,KAAKsU,kBAAkBrI,SAAStC,cAKnD5C,SAAU,SAAUjG,GAClB,MAAOd,MAAKiF,QAAQ,SAAWnE,IAOjCqU,kBAAmB,SAAU9S,GAU3B,OATI,IAASrC,KAAK4F,QAAQ6P,WA5S9BlR,EA6SmBX,SAAS,2FAEpB,WAAa5D,KAAK4F,QAAQ8P,aAC5BrT,EAAQA,EAAMe,QAAQ,UAAW,OAE/B,SAAYpD,KAAK4F,QAAQ8P,YAAgB,WAAa1V,KAAK4F,QAAQ8P,aAAgB,IAAS1V,KAAK4F,QAAQ6P,aAC3GpT,EAnTNkC,EAmT2BR,WAAW1B,IAE3BA,GAMTyS,uBAAwB,WACtB,IAAI,IAAU9U,KAAK4F,QAAQjB,gBACzB,OAAQ3E,KAAKqU,YAMf,KAAK,GAJDQ,MACAc,KAGKhU,EAAI,EAAGA,EAAI3B,KAAKqU,YAAYlT,OAAQQ,IAAK,CAChD,GAAIiU,GAAI5V,KAAKqU,YAAY1S,GAAGmI,QACvB6L,GAAMC,IACTf,EAAmBzO,KAAKuP,EAAMC,OAChCD,EAAMC,GAAGxP,KAAKpG,KAAKqU,YAAY1S,IAKjC,MAFAkT,GAAmBgB,KAAK,SAAUC,EAAGC,GAAK,MAAOA,GAAE,GAAGjM,SAAWgM,EAAE,GAAGhM,WAE/D+K,GA5UX,IAAAmB,GAAA3Q,ECAI4Q,EAAkB,WACpBjW,KAAK8G,UAAY,uBAGnBmP,GAAgB1V,WAEd2V,WAAY,SAAU1U,GAGpB,MAFAxB,MAAKmW,UAAU/P,KAAK5E,GAEbxB,MAIT4U,mBAAoB,WAClB,GAAIwB,EAKJ,IAHApW,KAAKqU,eAGDrU,KAAKwB,SAASgB,GAAG,UAGnB,MAFAxC,MAAK2F,mBAAmB4O,mBAEjBvU,IAIT,KAAK,GAAI2B,GAAI,EAAGA,EAAI3B,KAAKmW,UAAUhV,OAAQQ,IAGzC,GAAK5B,EAAE,QAAQsW,IAAIrW,KAAKmW,UAAUxU,IAAIR,OAAtC,CAKAiV,EAAmBpW,KAAKmW,UAAUxU,GAAG2U,KAAK,wBAAwB1B,qBAAqBP,WAEvF,KAAK,GAAIjE,GAAI,EAAGA,EAAIgG,EAAiBjV,OAAQiP,IAC3CpQ,KAAKoV,cAAcgB,EAAiBhG,GAAGrP,KAAMqV,EAAiBhG,GAAGzG,aAAcyM,EAAiBhG,GAAGtG,SAAUsM,EAAiBhG,GAAGwD,qBAPjI5T,MAAKmW,UAAU3P,OAAO7E,EAAG,EAU7B,OAAO3B,OAITqR,SAAU,WAER,GAAI,mBAAuBrR,MAAK4F,QAAQvD,MACtC,MAAOrC,MAAK4F,QAAQvD,KAGtB,IAAIrC,KAAKwB,SAASgB,GAAG,qBACnB,MAAOxC,MAAKqH,uBAAuBkP,OAAO,YAAYzJ,OAAS,EAGjE,IAAI9M,KAAKwB,SAASgB,GAAG,wBAAyB,CAC5C,GAAI6F,KAMJ,OAJArI,MAAKqH,uBAAuBkP,OAAO,YAAYjF,KAAK,WAClDjJ,EAAOjC,KAAKrG,EAAEC,MAAM8M,SAGfzE,EAIT,MAAIrI,MAAKwB,SAASgB,GAAG,WAAa,OAASxC,KAAKwB,SAASsL,SAIlD9M,KAAKwB,SAASsL,OAGvB0J,MAAO,WAGL,MAFAxW,MAAKmW,WAAanW,KAAKwB,UAEhBxB,MCrEX,IAAIyW,GAAiB,SAAU/E,EAAS9L,EAASwO,GAC/CpU,KAAKwB,SAAWzB,EAAE2R,EAGlB,IAAIgF,GAA2B1W,KAAKwB,SAAS8U,KAAK,UAClD,IAAII,EAQF,MALI,mBAAuBtC,IAAuBsC,EAAyB5Q,SAAWpC,OAAOiH,UAC3F+L,EAAyB5Q,OAASsO,EAClCsC,EAAyB3Q,cAAc2Q,EAAyB9Q,UAG3D8Q,CAIT,KAAK1W,KAAKwB,SAASL,OACjB,KAAM,IAAIiD,OAAM,gDAElB,IAAI,mBAAuBgQ,IAAuB,gBAAkBA,EAAoBtN,UACtF,KAAM,IAAI1C,OAAM,iDAGlB,OADApE,MAAK8F,OAASsO,GAAuB1Q,OAAOiH,QACrC3K,KAAKmK,KAAKvE,GAGnB6Q,GAAelW,WACb4J,KAAM,SAAUvE,GASd,MARA5F,MAAK8G,UAAY,UACjB9G,KAAK2W,YAAc,YACnB3W,KAAKuQ,OArCThM,EAqC+B1B,aAG3B7C,KAAK+F,cAAcH,GAGf5F,KAAKwB,SAASgB,GAAG,SA3CzB+B,EA2CkDjC,UAAUtC,KAAKwB,SAAUxB,KAAK4F,QAAQnE,UAAW,cAAgBzB,KAAKwB,SAASgB,GAAGxC,KAAK4F,QAAQnB,QACpIzE,KAAK4W,KAAK,eAGZ5W,KAAK6W,aAAe7W,KAAK8W,iBAAmB9W,KAAK4W,KAAK,iBAG/DC,WAAY,WACV,MAAQ7W,MAAKwB,SAASgB,GAAG,4CAAgDxC,KAAKwB,SAASgB,GAAG,WAAa,mBAAuBxC,MAAKwB,SAASD,KAAK,aAKnJuV,eAAgB,WACd,GAEE/V,GAEAgW,EAHA9J,EAAOjN,IAcT,IARIA,KAAK4F,QAAQhB,WAER,mBAAuB5E,MAAKwB,SAASD,KAAK,SAAWvB,KAAKwB,SAASD,KAAK,QAAQJ,OACvFnB,KAAK4F,QAAQhB,SAAW7D,EAAOf,KAAKwB,SAASD,KAAK,QAC3C,mBAAuBvB,MAAKwB,SAASD,KAAK,OAASvB,KAAKwB,SAASD,KAAK,MAAMJ,SACnFnB,KAAK4F,QAAQhB,SAAW5E,KAAKwB,SAASD,KAAK,QAGzCvB,KAAKwB,SAASgB,GAAG,WAAa,mBAAuBxC,MAAKwB,SAASD,KAAK,YAE1E,MADAvB,MAAK4F,QAAQhB,SAAW5E,KAAK4F,QAAQhB,UAAY5E,KAAKuQ,OAC/CvQ,KAAK4W,KAAK,uBAGZ,KAAK5W,KAAK4F,QAAQhB,SAEvB,MA/ENL,GA8EmBd,KAAK,wHAAyHzD,KAAKwB,UACzIxB,IAITA,MAAK4F,QAAQhB,SAAW5E,KAAK4F,QAAQhB,SAASxB,QAAQ,yBAA0B,IAG5E,mBAAuBrC,IACzBhB,EAAE,eAAiBgB,EAAO,MAAMuQ,KAAK,WAC/BvR,EAAEC,MAAMwC,GAAG,4CACbzC,EAAEC,MAAMuB,KAAK0L,EAAKrH,QAAQnE,UAAY,WAAYwL,EAAKrH,QAAQhB,WAMrE,KAAK,GADDoS,GAAqBhX,KAAKqH,uBACrB1F,EAAI,EAAGA,EAAIqV,EAAmB7V,OAAQQ,IAE7C,GADAoV,EAA0BhX,EAAEiX,EAAmBC,IAAItV,IAAI2U,KAAK,WACxD,mBAAuBS,GAAyB,CAE7C/W,KAAKwB,SAAS8U,KAAK,yBACtBS,EAAwBb,WAAWlW,KAAKwB,SAG1C,OAQJ,MAFAxB,MAAK4W,KAAK,gBAAgB,GAEnBG,GAA2B/W,KAAK4W,KAAK,yBAI9CA,KAAM,SAAUhN,EAAMsN,GACpB,GAAI3F,EAEJ,QAAQ3H,GACN,IAAK,cACH2H,EAAkBxR,EAAEoJ,OAClB,GAAIsI,GAAYzR,KAAKwB,SAAUxB,KAAK6F,WAAY7F,KAAK4F,SACrDlC,OAAOyT,eACPhE,aACF,MACF,KAAK,eACH5B,EAAkBxR,EAAEoJ,OAClB,GA/HV6M,GA+H2BhW,KAAKwB,SAAUxB,KAAK6F,WAAY7F,KAAK4F,QAAS5F,KAAK8F,QACpEpC,OAAOyT,cAET,MACF,KAAK,uBACH5F,EAAkBxR,EAAEoJ,OAClB,GArIV6M,GAqI2BhW,KAAKwB,SAAUxB,KAAK6F,WAAY7F,KAAK4F,QAAS5F,KAAK8F,QACpE,GAAImQ,GACJvS,OAAOyT,eACPX,OACF,MACF,SACE,KAAM,IAAIpS,OAAMwF,EAAO,mCAM3B,MAHI5J,MAAK4F,QAAQhB,UA9IrBL,EA+ImB9B,QAAQzC,KAAKwB,SAAUxB,KAAK4F,QAAQnE,UAAW,WAAYzB,KAAK4F,QAAQhB,UAEnF,mBAAuBsS,IACzBlX,KAAKwB,SAAS8U,KAAK,uBAAwB/E,GAEpCA,IAITvR,KAAKwB,SAAS8U,KAAK,UAAW/E,GAG9BA,EAAgBxK,SAAS,QAElBwK,IXzJX,IACE1Q,GAAId,MACJqX,EAAa,WANf7S,EAOiBX,SAAS,iHAgBtB3C,EAAc,UASlBlB,GAAEiN,OAAS,SAAUjM,EAAMsW,GACzB,GAAIlX,EAOJ,IANAiX,IACI,gBAAoB1W,WAAU,IAAM,kBAAsBA,WAAU,KACtEP,EAAUO,UAAU,GACpB2W,EAAW3W,UAAU,IAGnB,kBAAsB2W,GACxB,KAAM,IAAIjT,OAAM,mBAElBV,QAAOiH,QAAQzE,GAAGpF,EAAUC,GAAOd,EAAMoX,EAAUlX,KAGrDJ,EAAEuG,SAAW,SAAU4N,EAAUnT,EAAMb,GAErC,GADAkX,MACMlD,YAhDR8B,IAgD+C9B,YAAoBzC,IAC/D,KAAM,IAAIrN,OAAM,6BAElB,IAAI,gBAAoBrD,IAAQ,kBAAsBb,GACpD,KAAM,IAAIkE,OAAM,mBAElB8P,GAAShO,GAAGpF,EAAUC,GAAOd,EAAMC,KAGrCH,EAAE0G,YAAc,SAAU1F,EAAMb,GAE9B,GADAkX,IACI,gBAAoBrW,IAAQ,kBAAsBb,GACpD,KAAM,IAAIkE,OAAM,kBAClBV,QAAOiH,QAAQpE,IAAIzF,EAAUC,GAAOb,EAAGE,yBAGzCL,EAAE2G,cAAgB,SAAUwN,EAAUnT,GAEpC,GADAqW,MACMlD,YAlER8B,IAkE+C9B,YAAoBzC,IAC/D,KAAM,IAAIrN,OAAM,6BAClB8P,GAAS3N,IAAIzF,EAAUC,KAGzBhB,EAAEuX,eAAiB,SAAUvW,GAC3BqW,IACA1T,OAAOiH,QAAQpE,IAAIzF,EAAUC,IAC7BhB,EAAE,8BAA8BuR,KAAK,WACnC,GAAI4C,GAAWnU,EAAEC,MAAMsW,KAAK,UACxBpC,IACFA,EAAS3N,IAAIzF,EAAUC,OAM7BhB,EAAEwX,KAAO,SAAUxW,EAAMmT,GACvBkD,GACA,IAAII,GAAgBtD,YArFtB8B,IAqF6D9B,YAAoBzC,GAC3EpR,EAAOC,MAAMC,UAAUC,MAAMC,KAAKC,UAAW8W,EAAgB,EAAI,EACrEnX,GAAKM,QAAQG,EAAUC,IAClByW,IACHtD,EAAWxQ,OAAOiH,SAEpBuJ,EAASjP,QAAQrE,MAAMsT,EAAU7T,GA3FnC,IYAAoX,GAmBc1X,EAAEoJ,OAAO,GAAI1D,IACvBjE,SAAUzB,EAAE2X,UACZ/R,iBAAkB,KAClBI,cAAe,KACfyN,QAASiD,EACTkB,QAAS,aAKb5X,GAAEoJ,OA7BF6M,EA6BsBzV,UAAWkF,EAAgBlF,WACjDR,EAAEoJ,OAAOsI,EAAYlR,UAAWkF,EAAgBlF,WAEhDR,EAAEoJ,OAAOsN,EAAelW,UAAWkF,EAAgBlF,WAInDR,EAAEG,GAAGJ,QAAUC,EAAEG,GAAG0X,KAAO,SAAUhS,GACnC,GAAI5F,KAAKmB,OAAS,EAAG,CACnB,GAAI0W,KAMJ,OAJA7X,MAAKsR,KAAK,WACRuG,EAAUzR,KAAKrG,EAAEC,MAAMF,QAAQ8F;GAG1BiS,EAIT,MAAK9X,GAAEC,MAAMmB,OAMN,GAAIsV,GAAezW,KAAM4F,OAtDlCrB,GAiDiBd,KAAK,kDAUlB,mBAAuBC,QAAOyT,gBAChCzT,OAAOyT,kBA5DTM,EAgEQ7R,QAAU7F,EAAEoJ,OAhEpB5E,EAgEwCN,aAAaO,GAAkBd,OAAOoU,eAC9EpU,OAAOoU,cAjEPL,EAiE+B7R,QAG/BlC,OAAOiH,QAAUjH,OAAOkU,KApExBH,EAqEA/T,OAAO0H,aArEP7G,CAwEA,IAAIwT,GAAWrU,OAAOiH,QAAQmJ,mBAAqB,GAAI/J,GAAyBrG,OAAOoU,cAAc9N,WAAYtG,OAAOoU,cAAcE,KACtItU,QAAOuF,oBACPlJ,EAAEuR,KAAK,6GAA6GhJ,MAAM,KAAM,SAAU3G,EAAGsW,GAC3IvU,OAAOiH,QAAQsN,GAAUlY,EAAEsQ,MAAM0H,EAAUE,GAC3CvU,OAAOuF,iBAAiBgP,GAAU,WAEhC,MA9EJ1T,GA6EiBX,SAAS,yBAA0BqU,EAAQ,yEAA2EA,EAAS,UACrIvU,OAAOiH,QAAQsN,GAAQrX,MAAM8C,OAAOiH,QAASjK,cAOxDgD,OAAOqJ,UAAY,kBAAsBrJ,QAAOoU,cAAc/K,WAC5D,GAAIrJ,QAAOoU,cAAc/K,WAAYC,UAAW,GAAID,IAAYC,UAI9D,IAAUtJ,OAAOoU,cAAcI,UACjCnY,EAAE,WAEIA,EAAE,2BAA2BoB,QAC/BpB,EAAE,2BAA2BD,WA9FnC,IAAAA,GAAA2X,CbikEE,OAAO3X","file":"parsley.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jQuery')) :\n  typeof define === 'function' && define.amd ? define(['jQuery'], factory) :\n  global.parsley = factory(global.$)\n}(this, function ($) { 'use strict';\n\n  var globalID = 1,\n    pastWarnings = {};\n\n  var ParsleyUtils__ParsleyUtils = {\n    // Parsley DOM-API\n    // returns object from dom attributes and values\n    attr: function ($element, namespace, obj) {\n      var\n        i, attribute, attributes,\n        regex = new RegExp('^' + namespace, 'i');\n\n      if ('undefined' === typeof obj)\n        obj = {};\n      else {\n        // Clear all own properties. This won't affect prototype's values\n        for (i in obj) {\n          if (obj.hasOwnProperty(i))\n            delete obj[i];\n        }\n      }\n\n      if ('undefined' === typeof $element || 'undefined' === typeof $element[0])\n        return obj;\n\n      attributes = $element[0].attributes;\n      for (i = attributes.length; i--; ) {\n        attribute = attributes[i];\n\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n        }\n      }\n\n      return obj;\n    },\n\n    checkAttr: function ($element, namespace, checkAttr) {\n      return $element.is('[' + namespace + checkAttr + ']');\n    },\n\n    setAttr: function ($element, namespace, attr, value) {\n      $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n    },\n\n    generateID: function () {\n      return '' + globalID++;\n    },\n\n    /** Third party functions **/\n    // Zepto deserialize function\n    deserializeValue: function (value) {\n      var num;\n\n      try {\n        return value ?\n          value == \"true\" ||\n          (value == \"false\" ? false :\n          value == \"null\" ? null :\n          !isNaN(num = Number(value)) ? num :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value)\n          : value;\n      } catch (e) { return value; }\n    },\n\n    // Zepto camelize function\n    camelize: function (str) {\n      return str.replace(/-+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    // Zepto dasherize function\n    dasherize: function (str) {\n      return str.replace(/::/g, '/')\n        .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n        .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n        .replace(/_/g, '-')\n        .toLowerCase();\n    },\n\n    warn: function() {\n      if (window.console && 'function' === typeof window.console.warn)\n        window.console.warn.apply(window.console, arguments);\n    },\n\n    warnOnce: function(msg) {\n      if (!pastWarnings[msg]) {\n        pastWarnings[msg] = true;\n        this.warn.apply(this, arguments);\n      }\n    },\n\n    _resetWarnings: function() {\n      pastWarnings = {};\n    },\n\n    trimString: function(string) {\n      return string.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n    objectCreate: Object.create || (function () {\n      var Object = function () {};\n      return function (prototype) {\n        if (arguments.length > 1) {\n          throw Error('Second argument not supported');\n        }\n        if (typeof prototype != 'object') {\n          throw TypeError('Argument must be an object');\n        }\n        Object.prototype = prototype;\n        var result = new Object();\n        Object.prototype = null;\n        return result;\n      };\n    })()\n  };\n\n  var ParsleyUtils__default = ParsleyUtils__ParsleyUtils;\n\n  // All these options could be overriden and specified directly in DOM using\n  // `data-parsley-` default DOM-API\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\n  var ParsleyDefaults = {\n    // ### General\n\n    // Default data-namespace for DOM API\n    namespace: 'data-parsley-',\n\n    // Supported inputs by default\n    inputs: 'input, textarea, select',\n\n    // Excluded inputs by default\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n    // Stop validating field on highest priority failing constraint\n    priorityEnabled: true,\n\n    // ### Field only\n\n    // identifier used to group together inputs (e.g. radio buttons...)\n    multiple: null,\n\n    // identifier (or array of identifiers) used to validate only a select group of inputs\n    group: null,\n\n    // ### UI\n    // Enable\\Disable error messages\n    uiEnabled: true,\n\n    // Key events threshold before validation\n    validationThreshold: 3,\n\n    // Focused field on form validation error. 'first'|'last'|'none'\n    focus: 'first',\n\n    // `$.Event()` that will trigger validation. eg: `keyup`, `change`...\n    trigger: false,\n\n    // Class that would be added on every failing validation Parsley field\n    errorClass: 'parsley-error',\n\n    // Same for success validation\n    successClass: 'parsley-success',\n\n    // Return the `$element` that will receive these above success or error classes\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    classHandler: function (ParsleyField) {},\n\n    // Return the `$element` where errors will be appended\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    errorsContainer: function (ParsleyField) {},\n\n    // ul elem that would receive errors' list\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n    // li elem that would receive error message\n    errorTemplate: '<li></li>'\n  };\n\n  var ParsleyAbstract = function () {};\n\n  ParsleyAbstract.prototype = {\n    asyncSupport: true, // Deprecated\n\n    actualizeOptions: function () {\n      ParsleyUtils__default.attr(this.$element, this.options.namespace, this.domOptions);\n      if (this.parent && this.parent.actualizeOptions)\n        this.parent.actualizeOptions();\n      return this;\n    },\n\n    _resetOptions: function (initOptions) {\n      this.domOptions = ParsleyUtils__default.objectCreate(this.parent.options);\n      this.options = ParsleyUtils__default.objectCreate(this.domOptions);\n      // Shallow copy of ownProperties of initOptions:\n      for (var i in initOptions) {\n        if (initOptions.hasOwnProperty(i))\n          this.options[i] = initOptions[i];\n      }\n      this.actualizeOptions();\n    },\n\n    _listeners: null,\n\n    // Register a callback for the given event name.\n    // Callback is called with context as the first argument and the `this`.\n    // The context is the current parsley instance, or window.Parsley if global.\n    // A return value of `false` will interrupt the calls\n    on: function (name, fn) {\n      this._listeners = this._listeners || {};\n      var queue = this._listeners[name] = this._listeners[name] || [];\n      queue.push(fn);\n\n      return this;\n    },\n\n    // Deprecated. Use `on` instead.\n    subscribe: function(name, fn) {\n      $.listenTo(this, name.toLowerCase(), fn);\n    },\n\n    // Unregister a callback (or all if none is given) for the given event name\n    off: function (name, fn) {\n      var queue = this._listeners && this._listeners[name];\n      if (queue) {\n        if (!fn) {\n          delete this._listeners[name];\n        } else {\n          for(var i = queue.length; i--; )\n            if (queue[i] === fn)\n              queue.splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    // Deprecated. Use `off`\n    unsubscribe: function(name, fn) {\n      $.unsubscribeTo(this, name.toLowerCase());\n    },\n\n    // Trigger an event of the given name.\n    // A return value of `false` interrupts the callback chain.\n    // Returns false if execution was interrupted.\n    trigger: function (name, target, extraArg) {\n      target = target || this;\n      var queue = this._listeners && this._listeners[name];\n      var result, parentResult;\n      if (queue) {\n        for(var i = queue.length; i--; ) {\n          result = queue[i].call(target, target, extraArg);\n          if (result === false) return result;\n        }\n      }\n      if (this.parent) {\n        return this.parent.trigger(name, target, extraArg);\n      }\n      return true;\n    },\n\n    // Reset UI\n    reset: function () {\n      // Field case: just emit a reset event for UI\n      if ('ParsleyForm' !== this.__class__)\n        return this._trigger('reset');\n\n      // Form case: emit a reset event for each field\n      for (var i = 0; i < this.fields.length; i++)\n        this.fields[i]._trigger('reset');\n\n      this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function () {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      if ('ParsleyForm' !== this.__class__) {\n        this.$element.removeData('Parsley');\n        this.$element.removeData('ParsleyFieldMultiple');\n        this._trigger('destroy');\n\n        return;\n      }\n\n      // Form case: destroy all its fields and then destroy stored instance\n      for (var i = 0; i < this.fields.length; i++)\n        this.fields[i].destroy();\n\n      this.$element.removeData('Parsley');\n      this._trigger('destroy');\n    },\n\n    asyncIsValid: function() {\n      ParsleyUtils__default.warnOnce(\"asyncIsValid is deprecated; please use whenIsValid instead\");\n      return this.whenValid.apply(this, arguments);\n    },\n\n    _findRelatedMultiple: function() {\n      return this.parent.$element.find('[' + this.options.namespace + 'multiple=\"' + this.options.multiple +'\"]');\n    }\n  };\n\n  var requirementConverters = {\n    string: function(string) {\n      return string;\n    },\n    integer: function(string) {\n      if (isNaN(string))\n        throw 'Requirement is not an integer: \"' + string + '\"';\n      return parseInt(string, 10);\n    },\n    number: function(string) {\n      if (isNaN(string))\n        throw 'Requirement is not a number: \"' + string + '\"';\n      return parseFloat(string);\n    },\n    reference: function(string) { // Unused for now\n      var result = $(string);\n      if (result.length === 0)\n        throw 'No such reference: \"' + string + '\"';\n      return result;\n    },\n    boolean: function(string) {\n      return string !== 'false';\n    },\n    object: function(string) {\n      return ParsleyUtils__default.deserializeValue(string);\n    },\n    regexp: function(regexp) {\n      var flags = '';\n\n      // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n      if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\n        // Replace the regexp literal string with the first match group: ([gimy]*)\n        // If no flag is present, this will be a blank string\n        flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\n        // Again, replace the regexp literal string with the first match group:\n        // everything excluding the opening and closing slashes and the flags\n        regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n      } else {\n        // Anchor regexp:\n        regexp = '^' + regexp + '$';\n      }\n      return new RegExp(regexp, flags);\n    }\n  };\n\n  var convertArrayRequirement = function(string, length) {\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n    if (!m)\n      throw 'Requirement is not an array: \"' + string + '\"';\n    var values = m[1].split(',').map(ParsleyUtils__default.trimString);\n    if (values.length !== length)\n      throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n    return values;\n  };\n\n  var convertRequirement = function(requirementType, string) {\n    var converter = requirementConverters[requirementType || 'string'];\n    if (!converter)\n      throw 'Unknown requirement specification: \"' + requirementType + '\"';\n    return converter(string);\n  };\n\n  var convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\n    var main = null, extra = {};\n    for(var key in requirementSpec) {\n      if (key) {\n        var value = extraOptionReader(key);\n        if('string' === typeof value)\n          value = convertRequirement(requirementSpec[key], value);\n        extra[key] = value;\n      } else {\n        main = convertRequirement(requirementSpec[key], string);\n      }\n    }\n    return [main, extra];\n  };\n\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\n\n  var ParsleyValidator = function(spec) {\n    $.extend(true, this, spec);\n  };\n\n  ParsleyValidator.prototype = {\n    // Returns `true` iff the given `value` is valid according the given requirements.\n    validate: function(value, requirementFirstArg) {\n      if(this.fn) { // Legacy style validator\n\n        if(arguments.length > 3)  // If more args then value, requirement, instance...\n          requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\n        return this.fn.call(this, value, requirementFirstArg);\n      }\n\n      if ($.isArray(value)) {\n        if (!this.validateMultiple)\n          throw 'Validator `' + this.name + '` does not handle multiple values';\n        return this.validateMultiple.apply(this, arguments);\n      } else {\n        if (this.validateNumber) {\n          if (isNaN(value))\n            return false;\n          arguments[0] = parseFloat(arguments[0]);\n          return this.validateNumber.apply(this, arguments);\n        }\n        if (this.validateString) {\n          return this.validateString.apply(this, arguments);\n        }\n        throw 'Validator `' + this.name + '` only handles multiple values';\n      }\n    },\n\n    // Parses `requirements` into an array of arguments,\n    // according to `this.requirementType`\n    parseRequirements: function(requirements, extraOptionReader) {\n      if ('string' !== typeof requirements) {\n        // Assume requirement already parsed\n        // but make sure we return an array\n        return $.isArray(requirements) ? requirements : [requirements];\n      }\n      var type = this.requirementType;\n      if ($.isArray(type)) {\n        var values = convertArrayRequirement(requirements, type.length);\n        for (var i = 0; i < values.length; i++)\n          values[i] = convertRequirement(type[i], values[i]);\n        return values;\n      } else if ($.isPlainObject(type)) {\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n      } else {\n        return [convertRequirement(type, requirements)];\n      }\n    },\n    // Defaults:\n    requirementType: 'string',\n\n    priority: 2\n\n  };\n\n  var ParsleyValidatorRegistry = function (validators, catalog) {\n    this.__class__ = 'ParsleyValidatorRegistry';\n\n    // Default Parsley locale is en\n    this.locale = 'en';\n\n    this.init(validators || {}, catalog || {});\n  };\n\n  var typeRegexes =  {\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n    number: /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/,\n\n    integer: /^-?\\d+$/,\n\n    digits: /^\\d+$/,\n\n    alphanum: /^\\w+$/i,\n\n    url: new RegExp(\n        \"^\" +\n          // protocol identifier\n          \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n          // user:pass authentication\n          \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n          \"(?:\" +\n            // IP address exclusion\n            // private & local networks\n            // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n            // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n            // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n            // IP address dotted notation octets\n            // excludes loopback network 0.0.0.0\n            // excludes reserved space >= 224.0.0.0\n            // excludes network & broacast addresses\n            // (first & last IP address of each class)\n            \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n            \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n            \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n          \"|\" +\n            // host name\n            \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n            // domain name\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n            // TLD identifier\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n          \")\" +\n          // port number\n          \"(?::\\\\d{2,5})?\" +\n          // resource path\n          \"(?:/\\\\S*)?\" +\n        \"$\", 'i'\n      )\n  };\n  typeRegexes.range = typeRegexes.number;\n\n  ParsleyValidatorRegistry.prototype = {\n    init: function (validators, catalog) {\n      this.catalog = catalog;\n      // Copy prototype's validators:\n      this.validators = $.extend({}, this.validators);\n\n      for (var name in validators)\n        this.addValidator(name, validators[name].fn, validators[name].priority);\n\n      window.Parsley.trigger('parsley:validator:init');\n    },\n\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n    setLocale: function (locale) {\n      if ('undefined' === typeof this.catalog[locale])\n        throw new Error(locale + ' is not available in the catalog');\n\n      this.locale = locale;\n\n      return this;\n    },\n\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n    addCatalog: function (locale, messages, set) {\n      if ('object' === typeof messages)\n        this.catalog[locale] = messages;\n\n      if (true === set)\n        return this.setLocale(locale);\n\n      return this;\n    },\n\n    // Add a specific message for a given constraint in a given locale\n    addMessage: function (locale, name, message) {\n      if ('undefined' === typeof this.catalog[locale])\n        this.catalog[locale] = {};\n\n      this.catalog[locale][name.toLowerCase()] = message;\n\n      return this;\n    },\n\n    // Add a new validator\n    //\n    //    addValidator('custom', {\n    //        requirementType: ['integer', 'integer'],\n    //        validateString: function(value, from, to) {},\n    //        priority: 22,\n    //        messages: {\n    //          en: \"Hey, that's no good\",\n    //          fr: \"Aye aye, pas bon du tout\",\n    //        }\n    //    })\n    //\n    // Old API was addValidator(name, function, priority)\n    //\n    addValidator: function (name, arg1, arg2) {\n      if (this.validators[name])\n        ParsleyUtils.warn('Validator \"' + name + '\" is already defined.');\n      else if (ParsleyDefaults.hasOwnProperty(name)) {\n        ParsleyUtils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n        return;\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    updateValidator: function (name, arg1, arg2) {\n      if (!this.validators[name]) {\n        ParsleyUtils.warn('Validator \"' + name + '\" is not already defined.');\n        return this.addValidator.apply(this, arguments);\n      }\n      return this._setValidator(this, arguments);\n    },\n\n    removeValidator: function (name) {\n      if (!this.validators[name])\n        ParsleyUtils.warn('Validator \"' + name + '\" is not defined.');\n\n      delete this.validators[name];\n\n      return this;\n    },\n\n    _setValidator: function (name, validator, priority) {\n      if ('object' !== typeof validator) {\n        // Old style validator, with `fn` and `priority`\n        validator = {\n          fn: validator,\n          priority: priority\n        };\n      }\n      if (!validator.validate) {\n        validator = new ParsleyValidator(validator);\n      }\n      this.validators[name] = validator;\n\n      for (var locale in validator.messages || {})\n        this.addMessage(locale, name, validator.messages[locale]);\n\n      return this;\n    },\n\n    getErrorMessage: function (constraint) {\n      var message;\n\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\n      if ('type' === constraint.name) {\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\n        message = typeMessages[constraint.requirements];\n      } else\n        message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n    },\n\n    // Kind of light `sprintf()` implementation\n    formatMessage: function (string, parameters) {\n      if ('object' === typeof parameters) {\n        for (var i in parameters)\n          string = this.formatMessage(string, parameters[i]);\n\n        return string;\n      }\n\n      return 'string' === typeof string ? string.replace(new RegExp('%s', 'i'), parameters) : '';\n    },\n\n    // Here is the Parsley default validators list.\n    // A validator is an object with the following key values:\n    //  - priority: an integer\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n    // Alternatively, a validator can be a function that returns such an object\n    //\n    validators: {\n      notblank: {\n        validateString: function(value) {\n          return /\\S/.test(value);\n        },\n        priority: 2\n      },\n      required: {\n        validateMultiple: function(values) {\n          return values.length > 0;\n        },\n        validateString: function(value) {\n          return /\\S/.test(value);\n        },\n        priority: 512\n      },\n      type: {\n        validateString: function(value, type) {\n          var regex = typeRegexes[type];\n          if (!regex)\n            throw new Error('validator type `' + type + '` is not supported');\n          return regex.test(value);\n        },\n        priority: 256\n      },\n      pattern: {\n        validateString: function(value, regexp) {\n          return regexp.test(value);\n        },\n        requirementType: 'regexp',\n        priority: 64\n      },\n      minlength: {\n        validateString: function (value, requirement) {\n          return value.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxlength: {\n        validateString: function (value, requirement) {\n          return value.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      length: {\n        validateString: function (value, min, max) {\n          return value.length >= min && value.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      mincheck: {\n        validateMultiple: function (values, requirement) {\n          return values.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxcheck: {\n        validateMultiple: function (values, requirement) {\n          return values.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      check: {\n        validateMultiple: function (values, min, max) {\n          return values.length >= min && values.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      min: {\n        validateNumber: function (value, requirement) {\n          return value >= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      max: {\n        validateNumber: function (value, requirement) {\n          return value <= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      range: {\n        validateNumber: function (value, min, max) {\n          return value >= min && value <= max;\n        },\n        requirementType: ['number', 'number'],\n        priority: 30\n      },\n      equalto: {\n        validateString: function (value, refOrValue) {\n          var $reference = $(refOrValue);\n          if ($reference.length)\n            return value === $reference.val();\n          else\n            return value === refOrValue;\n        },\n        priority: 256\n      }\n    }\n  };\n\n  var ParsleyUI = function (options) {\n    this.__class__ = 'ParsleyUI';\n  };\n\n  ParsleyUI.prototype = {\n    listen: function () {\n      var that = this;\n      window.Parsley\n      .on('form:init',       function () { that.setupForm (this); } )\n      .on('field:init',      function () { that.setupField(this); } )\n      .on('field:validated', function () { that.reflow    (this); } )\n      .on('form:validated',  function () { that.focus     (this); } )\n      .on('field:reset',     function () { that.reset     (this); } )\n      .on('form:destroy',    function () { that.destroy   (this); } )\n      .on('field:destroy',   function () { that.destroy   (this); } );\n\n      return this;\n    },\n\n    reflow: function (fieldInstance) {\n      // If this field has not an active UI (case for multiples) don't bother doing something\n      if ('undefined' === typeof fieldInstance._ui || false === fieldInstance._ui.active)\n        return;\n\n      // Diff between two validation results\n      var diff = this._diff(fieldInstance.validationResult, fieldInstance._ui.lastValidationResult);\n\n      // Then store current validation result for next reflow\n      fieldInstance._ui.lastValidationResult = fieldInstance.validationResult;\n\n      // Field have been validated at least once if here. Useful for binded key events...\n      fieldInstance._ui.validatedOnce = true;\n\n      // Handle valid / invalid / none field class\n      this.manageStatusClass(fieldInstance);\n\n      // Add, remove, updated errors messages\n      this.manageErrorsMessages(fieldInstance, diff);\n\n      // Triggers impl\n      this.actualizeTriggers(fieldInstance);\n\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n      if ((diff.kept.length || diff.added.length) && true !== fieldInstance._ui.failedOnce)\n        this.manageFailingFieldTrigger(fieldInstance);\n    },\n\n    // Returns an array of field's error message(s)\n    getErrorsMessages: function (fieldInstance) {\n      // No error message, field is valid\n      if (true === fieldInstance.validationResult)\n        return [];\n\n      var messages = [];\n\n      for (var i = 0; i < fieldInstance.validationResult.length; i++)\n        messages.push(this._getErrorMessage(fieldInstance, fieldInstance.validationResult[i].assert));\n\n      return messages;\n    },\n\n    manageStatusClass: function (fieldInstance) {\n      if (fieldInstance.hasConstraints() && fieldInstance.needsValidation() && true === fieldInstance.validationResult)\n        this._successClass(fieldInstance);\n      else if (fieldInstance.validationResult.length > 0)\n        this._errorClass(fieldInstance);\n      else\n        this._resetClass(fieldInstance);\n    },\n\n    manageErrorsMessages: function (fieldInstance, diff) {\n      if ('undefined' !== typeof fieldInstance.options.errorsMessagesDisabled)\n        return;\n\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n      if ('undefined' !== typeof fieldInstance.options.errorMessage) {\n        if ((diff.added.length || diff.kept.length)) {\n          this._insertErrorWrapper(fieldInstance);\n\n          if (0 === fieldInstance._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\n            fieldInstance._ui.$errorsWrapper\n              .append(\n                $(fieldInstance.options.errorTemplate)\n                .addClass('parsley-custom-error-message')\n              );\n\n          return fieldInstance._ui.$errorsWrapper\n            .addClass('filled')\n            .find('.parsley-custom-error-message')\n            .html(fieldInstance.options.errorMessage);\n        }\n\n        return fieldInstance._ui.$errorsWrapper\n          .removeClass('filled')\n          .find('.parsley-custom-error-message')\n          .remove();\n      }\n\n      // Show, hide, update failing constraints messages\n      for (var i = 0; i < diff.removed.length; i++)\n        this.removeError(fieldInstance, diff.removed[i].assert.name, true);\n\n      for (i = 0; i < diff.added.length; i++)\n        this.addError(fieldInstance, diff.added[i].assert.name, undefined, diff.added[i].assert, true);\n\n      for (i = 0; i < diff.kept.length; i++)\n        this.updateError(fieldInstance, diff.kept[i].assert.name, undefined, diff.kept[i].assert, true);\n    },\n\n    // TODO: strange API here, intuitive for manual usage with addError(pslyInstance, 'foo', 'bar')\n    // but a little bit complex for above internal usage, with forced undefined parameter...\n    addError: function (fieldInstance, name, message, assert, doNotUpdateClass) {\n      this._insertErrorWrapper(fieldInstance);\n      fieldInstance._ui.$errorsWrapper\n        .addClass('filled')\n        .append(\n          $(fieldInstance.options.errorTemplate)\n          .addClass('parsley-' + name)\n          .html(message || this._getErrorMessage(fieldInstance, assert))\n        );\n\n      if (true !== doNotUpdateClass)\n        this._errorClass(fieldInstance);\n    },\n\n    // Same as above\n    updateError: function (fieldInstance, name, message, assert, doNotUpdateClass) {\n      fieldInstance._ui.$errorsWrapper\n        .addClass('filled')\n        .find('.parsley-' + name)\n        .html(message || this._getErrorMessage(fieldInstance, assert));\n\n      if (true !== doNotUpdateClass)\n        this._errorClass(fieldInstance);\n    },\n\n    // Same as above twice\n    removeError: function (fieldInstance, name, doNotUpdateClass) {\n      fieldInstance._ui.$errorsWrapper\n        .removeClass('filled')\n        .find('.parsley-' + name)\n        .remove();\n\n      // edge case possible here: remove a standard Parsley error that is still failing in fieldInstance.validationResult\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n      if (true !== doNotUpdateClass)\n        this.manageStatusClass(fieldInstance);\n    },\n\n    focus: function (formInstance) {\n      formInstance._focusedField = null;\n\n      if (true === formInstance.validationResult || 'none' === formInstance.options.focus)\n        return null;\n\n      for (var i = 0; i < formInstance.fields.length; i++) {\n        var field = formInstance.fields[i];\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n          formInstance._focusedField = field.$element;\n          if ('first' === formInstance.options.focus)\n            break;\n        }\n      }\n\n      if (null === formInstance._focusedField)\n        return null;\n\n      return formInstance._focusedField.focus();\n    },\n\n    _getErrorMessage: function (fieldInstance, constraint) {\n      var customConstraintErrorMessage = constraint.name + 'Message';\n\n      if ('undefined' !== typeof fieldInstance.options[customConstraintErrorMessage])\n        return window.Parsley.formatMessage(fieldInstance.options[customConstraintErrorMessage], constraint.requirements);\n\n      return window.Parsley.getErrorMessage(constraint);\n    },\n\n    _diff: function (newResult, oldResult, deep) {\n      var\n        added = [],\n        kept = [];\n\n      for (var i = 0; i < newResult.length; i++) {\n        var found = false;\n\n        for (var j = 0; j < oldResult.length; j++)\n          if (newResult[i].assert.name === oldResult[j].assert.name) {\n            found = true;\n            break;\n          }\n\n        if (found)\n          kept.push(newResult[i]);\n        else\n          added.push(newResult[i]);\n      }\n\n      return {\n        kept: kept,\n        added: added,\n        removed: !deep ? this._diff(oldResult, newResult, true).added : []\n      };\n    },\n\n    setupForm: function (formInstance) {\n      formInstance.$element.on('submit.Parsley', false, $.proxy(formInstance.onSubmitValidate, formInstance));\n\n      // UI could be disabled\n      if (false === formInstance.options.uiEnabled)\n        return;\n\n      formInstance.$element.attr('novalidate', '');\n    },\n\n    setupField: function (fieldInstance) {\n      var _ui = { active: false };\n\n      // UI could be disabled\n      if (false === fieldInstance.options.uiEnabled)\n        return;\n\n      _ui.active = true;\n\n      // Give field its Parsley id in DOM\n      fieldInstance.$element.attr(fieldInstance.options.namespace + 'id', fieldInstance.__id__);\n\n      /** Generate important UI elements and store them in fieldInstance **/\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n      _ui.$errorClassHandler = this._manageClassHandler(fieldInstance);\n\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n      _ui.errorsWrapperId = 'parsley-id-' + (fieldInstance.options.multiple ? 'multiple-' + fieldInstance.options.multiple : fieldInstance.__id__);\n      _ui.$errorsWrapper = $(fieldInstance.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n      _ui.lastValidationResult = [];\n      _ui.validatedOnce = false;\n      _ui.validationInformationVisible = false;\n\n      // Store it in fieldInstance for later\n      fieldInstance._ui = _ui;\n\n      // Bind triggers first time\n      this.actualizeTriggers(fieldInstance);\n    },\n\n    // Determine which element will have `parsley-error` and `parsley-success` classes\n    _manageClassHandler: function (fieldInstance) {\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n      if ('string' === typeof fieldInstance.options.classHandler && $(fieldInstance.options.classHandler).length)\n        return $(fieldInstance.options.classHandler);\n\n      // Class handled could also be determined by function given in Parsley options\n      var $handler = fieldInstance.options.classHandler(fieldInstance);\n\n      // If this function returned a valid existing DOM element, go for it\n      if ('undefined' !== typeof $handler && $handler.length)\n        return $handler;\n\n      // Otherwise, if simple element (input, texatrea, select...) it will perfectly host the classes\n      if (!fieldInstance.options.multiple || fieldInstance.$element.is('select'))\n        return fieldInstance.$element;\n\n      // But if multiple element (radio, checkbox), that would be their parent\n      return fieldInstance.$element.parent();\n    },\n\n    _insertErrorWrapper: function (fieldInstance) {\n      var $errorsContainer;\n\n      // Nothing to do if already inserted\n      if (0 !== fieldInstance._ui.$errorsWrapper.parent().length)\n        return fieldInstance._ui.$errorsWrapper.parent();\n\n      if ('string' === typeof fieldInstance.options.errorsContainer) {\n        if ($(fieldInstance.options.errorsContainer).length)\n          return $(fieldInstance.options.errorsContainer).append(fieldInstance._ui.$errorsWrapper);\n        else\n          ParsleyUtils__default.warn('The errors container `' + fieldInstance.options.errorsContainer + '` does not exist in DOM');\n      }\n      else if ('function' === typeof fieldInstance.options.errorsContainer)\n        $errorsContainer = fieldInstance.options.errorsContainer(fieldInstance);\n\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\n        return $errorsContainer.append(fieldInstance._ui.$errorsWrapper);\n\n      var $from = fieldInstance.$element;\n      if (fieldInstance.options.multiple)\n        $from = $from.parent();\n      return $from.after(fieldInstance._ui.$errorsWrapper);\n    },\n\n    actualizeTriggers: function (fieldInstance) {\n      var $toBind = fieldInstance.$element;\n      if (fieldInstance.options.multiple)\n        $toBind = $('[' + fieldInstance.options.namespace + 'multiple=\"' + fieldInstance.options.multiple + '\"]');\n\n      // Remove Parsley events already binded on this field\n      $toBind.off('.Parsley');\n\n      // If no trigger is set, all good\n      if (false === fieldInstance.options.trigger)\n        return;\n\n      var triggers = fieldInstance.options.trigger.replace(/^\\s+/g , '').replace(/\\s+$/g , '');\n\n      if ('' === triggers)\n        return;\n\n      // Bind fieldInstance.eventValidate if exists (for parsley.ajax for example), ParsleyUI.eventValidate otherwise\n      $toBind.on(\n        triggers.split(' ').join('.Parsley ') + '.Parsley',\n        $.proxy('function' === typeof fieldInstance.eventValidate ? fieldInstance.eventValidate : this.eventValidate, fieldInstance));\n    },\n\n    // Called through $.proxy with fieldInstance. `this` context is ParsleyField\n    eventValidate: function (event) {\n      // For keyup, keypress, keydown... events that could be a little bit obstrusive\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n      if (new RegExp('key').test(event.type))\n        if (!this._ui.validationInformationVisible && this.getValue().length <= this.options.validationThreshold)\n          return;\n\n      this._ui.validatedOnce = true;\n      this.validate();\n    },\n\n    manageFailingFieldTrigger: function (fieldInstance) {\n      fieldInstance._ui.failedOnce = true;\n\n      // Radio and checkboxes fields must bind every field multiple\n      if (fieldInstance.options.multiple)\n        $('[' + fieldInstance.options.namespace + 'multiple=\"' + fieldInstance.options.multiple + '\"]').each(function () {\n          if (!new RegExp('change', 'i').test($(this).parsley().options.trigger || ''))\n            return $(this).on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n        });\n\n      // Select case\n      if (fieldInstance.$element.is('select'))\n        if (!new RegExp('change', 'i').test(fieldInstance.options.trigger || ''))\n          return fieldInstance.$element.on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n\n      // All other inputs fields\n      if (!new RegExp('keyup', 'i').test(fieldInstance.options.trigger || ''))\n        return fieldInstance.$element.on('keyup.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n    },\n\n    reset: function (parsleyInstance) {\n      // Reset all event listeners\n      this.actualizeTriggers(parsleyInstance);\n      parsleyInstance.$element.off('.ParsleyFailedOnce');\n\n      // Nothing to do if UI never initialized for this field\n      if ('undefined' === typeof parsleyInstance._ui)\n        return;\n\n      if ('ParsleyForm' === parsleyInstance.__class__)\n        return;\n\n      // Reset all errors' li\n      parsleyInstance._ui.$errorsWrapper\n        .removeClass('filled')\n        .children()\n        .remove();\n\n      // Reset validation class\n      this._resetClass(parsleyInstance);\n\n      // Reset validation flags and last validation result\n      parsleyInstance._ui.validatedOnce = false;\n      parsleyInstance._ui.lastValidationResult = [];\n      parsleyInstance._ui.validationInformationVisible = false;\n      parsleyInstance._ui.failedOnce = false;\n    },\n\n    destroy: function (parsleyInstance) {\n      this.reset(parsleyInstance);\n\n      if ('ParsleyForm' === parsleyInstance.__class__)\n        return;\n\n      if ('undefined' !== typeof parsleyInstance._ui)\n        parsleyInstance._ui.$errorsWrapper.remove();\n\n      delete parsleyInstance._ui;\n    },\n\n    _successClass: function (fieldInstance) {\n      fieldInstance._ui.validationInformationVisible = true;\n      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.errorClass).addClass(fieldInstance.options.successClass);\n    },\n    _errorClass: function (fieldInstance) {\n      fieldInstance._ui.validationInformationVisible = true;\n      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).addClass(fieldInstance.options.errorClass);\n    },\n    _resetClass: function (fieldInstance) {\n      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).removeClass(fieldInstance.options.errorClass);\n    }\n  };\n\n  var ParsleyForm = function (element, domOptions, options) {\n    this.__class__ = 'ParsleyForm';\n    this.__id__ = ParsleyUtils__default.generateID();\n\n    this.$element = $(element);\n    this.domOptions = domOptions;\n    this.options = options;\n    this.parent = window.Parsley;\n\n    this.fields = [];\n    this.validationResult = null;\n  };\n\n  var ParsleyForm__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  ParsleyForm.prototype = {\n    onSubmitValidate: function (event) {\n      var that = this;\n\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n      if (true === event.parsley)\n        return;\n\n      // Because some validations might be asynchroneous,\n      // we cancel this submit and will fake it after validation.\n      event.stopImmediatePropagation();\n      event.preventDefault();\n\n      this.whenValidate(undefined, undefined, event)\n        .done(function() { that._submit(); })\n        .always(function() { that._submitSource = null; });\n\n      return this;\n    },\n\n    // internal\n    // _submit submits the form, this time without going through the validations.\n    // Care must be taken to \"fake\" the actual submit button being clicked.\n    _submit: function() {\n      if (false === this._trigger('submit'))\n        return;\n      this.$element.find('.parsley_synthetic_submit_button').remove();\n      if (this._submitSource) {\n        $('<input class=\".parsley_synthetic_submit_button\" type=\"hidden\">')\n        .attr('name', this._submitSource.name)\n        .attr('value', this._submitSource.value)\n        .appendTo(this.$element);\n      }\n      this.$element.trigger($.extend($.Event('submit'), { parsley: true }));\n    },\n\n    // Performs validation on fields while triggering events.\n    // @returns `true` if al validations succeeds, `false`\n    // if a failure is immediately detected, or `null`\n    // if dependant on a promise.\n    // Prefer `whenValidate`.\n    validate: function (group, force, event) {\n      return ParsleyForm__statusMapping[ this.whenValidate(group, force, event).state() ];\n    },\n\n    whenValidate: function (group, force, event) {\n      var that = this;\n      this.submitEvent = event;\n      this.validationResult = true;\n\n      // fire validate event to eventually modify things before very validation\n      this._trigger('validate');\n\n      // Refresh form DOM options and form's fields that could have changed\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function(){\n        return $.map(this.fields, function(field) {\n          // do not validate a field if not the same as given validation group\n          if (!group || that._isFieldInGroup(field, group))\n            return field.whenValidate(force);\n        });\n      });\n      return $.when.apply($, promises)\n        .done(  function() { that._trigger('success'); })\n        .fail(  function() { that.validationResult = false; that._trigger('error'); })\n        .always(function() { that._trigger('validated'); });\n    },\n\n    // Iterate over refreshed fields, and stop on first failure.\n    // Returns `true` if all fields are valid, `false` if a failure is detected\n    // or `null` if the result depends on an unresolved promise.\n    // Prefer using `whenValid` instead.\n    isValid: function (group, force) {\n      return ParsleyForm__statusMapping[ this.whenValid(group, force).state() ];\n    },\n\n    // Iterate over refreshed fields and validate them.\n    // Returns a promise.\n    // A validation that immediately fails will interrupt the validations.\n    whenValid: function (group, force) {\n      var that = this;\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function(){\n        return $.map(this.fields, function(field) {\n          // do not validate a field if not the same as given validation group\n          if (!group || that._isFieldInGroup(field, group))\n            return field.whenValid(force);\n        });\n      });\n      return $.when.apply($, promises);\n    },\n\n    _isFieldInGroup: function (field, group) {\n      if($.isArray(field.options.group))\n        return -1 !== $.inArray(group, field.options.group);\n      return field.options.group === group;\n    },\n\n    _refreshFields: function () {\n      return this.actualizeOptions()._bindFields();\n    },\n\n    _bindFields: function () {\n      var self = this,\n        oldFields = this.fields;\n\n      this.fields = [];\n      this.fieldsMappedById = {};\n\n      this._withoutReactualizingFormOptions(function(){\n        this.$element\n        .find(this.options.inputs)\n        .not(this.options.excluded)\n        .each(function () {\n          var fieldInstance = new Parsley.Factory(this, {}, self);\n\n          // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children\n          if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded))\n            if ('undefined' === typeof self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {\n              self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;\n              self.fields.push(fieldInstance);\n            }\n        });\n\n        $(oldFields).not(self.fields).each(function () {\n          this._trigger('reset');\n        });\n      });\n      return this;\n    },\n\n    // Internal only.\n    // Looping on a form's fields to do validation or similar\n    // will trigger reactualizing options on all of them, which\n    // in turn will reactualize the form's options.\n    // To avoid calling actualizeOptions so many times on the form\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\n    // the method actualizeOptions on this form while `fn` is called.\n    _withoutReactualizingFormOptions: function (fn) {\n      var oldActualizeOptions = this.actualizeOptions;\n      this.actualizeOptions = function() { return this; };\n      var result = fn.call(this); // Keep the current `this`.\n      this.actualizeOptions = oldActualizeOptions;\n      return result;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    // Returns true iff event is not interrupted and default not prevented.\n    _trigger: function (eventName) {\n      return this.trigger('form:' + eventName);\n    }\n\n  };\n\n  var ConstraintFactory = function (parsleyField, name, requirements, priority, isDomConstraint) {\n    if (!new RegExp('ParsleyField').test(parsleyField.__class__))\n      throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');\n\n    var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n    var validator = new ParsleyValidator(validatorSpec);\n\n    $.extend(this, {\n      validator: validator,\n      name: name,\n      requirements: requirements,\n      priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n      isDomConstraint: true === isDomConstraint\n    });\n    this._parseRequirements(parsleyField.options);\n  };\n\n  var capitalize = function(str) {\n    var cap = str[0].toUpperCase();\n    return cap + str.slice(1);\n  };\n\n  ConstraintFactory.prototype = {\n    validate: function(value, instance) {\n      var args = this.requirementList.slice(0); // Make copy\n      args.unshift(value);\n      args.push(instance);\n      return this.validator.validate.apply(this.validator, args);\n    },\n\n    _parseRequirements: function(options) {\n      var that = this;\n      this.requirementList = this.validator.parseRequirements(this.requirements, function(key) {\n        return options[that.name + capitalize(key)];\n      });\n    }\n  };\n\n  var ParsleyField = function (field, domOptions, options, parsleyFormInstance) {\n    this.__class__ = 'ParsleyField';\n    this.__id__ = ParsleyUtils__default.generateID();\n\n    this.$element = $(field);\n\n    // Set parent if we have one\n    if ('undefined' !== typeof parsleyFormInstance) {\n      this.parent = parsleyFormInstance;\n    }\n\n    this.options = options;\n    this.domOptions = domOptions;\n\n    // Initialize some properties\n    this.constraints = [];\n    this.constraintsByName = {};\n    this.validationResult = [];\n\n    // Bind constraints\n    this._bindConstraints();\n  };\n\n  var parsley_field__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  ParsleyField.prototype = {\n    // # Public API\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns `true`, an array of the validators that failed, or\n    // `null` if validation is not finished. Prefer using whenValidate\n    validate: function (force) {\n      var promise = this.whenValidate(force);\n      switch (promise.state()) {\n        case 'pending': return null;\n        case 'resolved': return true;\n        case 'rejected': return this.validationResult;\n      }\n    },\n\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns a promise that succeeds only when all validations do.\n    whenValidate: function (force) {\n      var that = this;\n\n      this.value = this.getValue();\n\n      // Field Validate event. `this.value` could be altered for custom needs\n      this._trigger('validate');\n\n      return this.whenValid(force, this.value)\n        .done(function()   { that._trigger('success'); })\n        .fail(function()   { that._trigger('error'); })\n        .always(function() { that._trigger('validated'); });\n    },\n\n    hasConstraints: function () {\n      return 0 !== this.constraints.length;\n    },\n\n    // An empty optional field does not need validation\n    needsValidation: function (value) {\n      if ('undefined' === typeof value)\n        value = this.getValue();\n\n      // If a field is empty and not required, it is valid\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\n        return false;\n\n      return true;\n    },\n\n    // Just validate field. Do not trigger any event.\n    // Returns `true` iff all constraints pass, `false` if there are failures,\n    // or `null` if the result can not be determined yet (depends on a promise)\n    // Prefer using `whenValid`.\n    isValid: function (force, value) {\n      return parsley_field__statusMapping[this.whenValid(force, value).state()];\n    },\n\n    whenValid: function (force, value) {\n      // Recompute options and rebind constraints to have latest changes\n      this.refreshConstraints();\n      this.validationResult = true;\n\n      // A field without constraint is valid\n      if (!this.hasConstraints())\n        return $.when();\n\n      // Value could be passed as argument, needed to add more power to 'parsley:field:validate'\n      if ('undefined' === typeof value || null === value)\n        value = this.getValue();\n\n      if (!this.needsValidation(value) && true !== force)\n        return $.when();\n\n      var groupedConstraints = this._getGroupedConstraints();\n      var promises = [];\n      var that = this;\n      $.each(groupedConstraints, function(_, constraints) {\n        // Process one group of constraints at a time, we validate the constraints\n        // and combine the promises together.\n        var promise = $.when.apply($,\n          $.map(constraints, $.proxy(that, '_validateConstraint', value))\n        );\n        promises.push(promise);\n        if (promise.state() === 'rejected')\n          return false; // Interrupt processing if a group has already failed\n      });\n      return $.when.apply($, promises);\n    },\n\n    // @returns a promise\n    _validateConstraint: function(value, constraint) {\n      var that = this;\n      var result = constraint.validate(value, this);\n      // Map false to a failed promise\n      if (false === result)\n        result = $.Deferred().reject();\n      // Make sure we return a promise and that we record failures\n      return $.when(result).fail(function() {\n        if (true === that.validationResult)\n          that.validationResult = [];\n        that.validationResult.push({assert: constraint});\n      });\n    },\n\n    // @returns Parsley field computed value that could be overrided or configured in DOM\n    getValue: function () {\n      var value;\n\n      // Value could be overriden in DOM or with explicit options\n      if ('function' === typeof this.options.value)\n        value = this.options.value(this);\n      else if ('undefined' !== typeof this.options.value)\n        value = this.options.value;\n      else\n        value = this.$element.val();\n\n      // Handle wrong DOM or configurations\n      if ('undefined' === typeof value || null === value)\n        return '';\n\n      return this._handleWhitespace(value);\n    },\n\n    // Actualize options that could have change since previous validation\n    // Re-bind accordingly constraints (could be some new, removed or updated)\n    refreshConstraints: function () {\n      return this.actualizeOptions()._bindConstraints();\n    },\n\n    /**\n    * Add a new constraint to a field\n    *\n    * @method addConstraint\n    * @param {String}   name\n    * @param {Mixed}    requirements      optional\n    * @param {Number}   priority          optional\n    * @param {Boolean}  isDomConstraint   optional\n    */\n    addConstraint: function (name, requirements, priority, isDomConstraint) {\n\n      if (window.Parsley._validatorRegistry.validators[name]) {\n        var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);\n\n        // if constraint already exist, delete it and push new version\n        if ('undefined' !== this.constraintsByName[constraint.name])\n          this.removeConstraint(constraint.name);\n\n        this.constraints.push(constraint);\n        this.constraintsByName[constraint.name] = constraint;\n      }\n\n      return this;\n    },\n\n    // Remove a constraint\n    removeConstraint: function (name) {\n      for (var i = 0; i < this.constraints.length; i++)\n        if (name === this.constraints[i].name) {\n          this.constraints.splice(i, 1);\n          break;\n        }\n      delete this.constraintsByName[name];\n      return this;\n    },\n\n    // Update a constraint (Remove + re-add)\n    updateConstraint: function (name, parameters, priority) {\n      return this.removeConstraint(name)\n        .addConstraint(name, parameters, priority);\n    },\n\n    // # Internals\n\n    // Internal only.\n    // Bind constraints from config + options + DOM\n    _bindConstraints: function () {\n      var constraints = [], constraintsByName = {};\n\n      // clean all existing DOM constraints to only keep javascript user constraints\n      for (var i = 0; i < this.constraints.length; i++)\n        if (false === this.constraints[i].isDomConstraint) {\n          constraints.push(this.constraints[i]);\n          constraintsByName[this.constraints[i].name] = this.constraints[i];\n        }\n\n      this.constraints = constraints;\n      this.constraintsByName = constraintsByName;\n\n      // then re-add Parsley DOM-API constraints\n      for (var name in this.options)\n        this.addConstraint(name, this.options[name], undefined, true);\n\n      // finally, bind special HTML5 constraints\n      return this._bindHtml5Constraints();\n    },\n\n    // Internal only.\n    // Bind specific HTML5 constraints to be HTML5 compliant\n    _bindHtml5Constraints: function () {\n      // html5 required\n      if (this.$element.hasClass('required') || this.$element.attr('required'))\n        this.addConstraint('required', true, undefined, true);\n\n      // html5 pattern\n      if ('string' === typeof this.$element.attr('pattern'))\n        this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n      // range\n      if ('undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))\n        this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n      // HTML5 min\n      else if ('undefined' !== typeof this.$element.attr('min'))\n        this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n      // HTML5 max\n      else if ('undefined' !== typeof this.$element.attr('max'))\n        this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n\n      // length\n      if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength'))\n        this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n      // HTML5 minlength\n      else if ('undefined' !== typeof this.$element.attr('minlength'))\n        this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n      // HTML5 maxlength\n      else if ('undefined' !== typeof this.$element.attr('maxlength'))\n        this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n\n      // html5 types\n      var type = this.$element.attr('type');\n\n      if ('undefined' === typeof type)\n        return this;\n\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n      if ('number' === type) {\n        if (('undefined' === typeof this.$element.attr('step')) || (0 === parseFloat(this.$element.attr('step')) % 1)) {\n          return this.addConstraint('type', 'integer', undefined, true);\n        } else {\n          return this.addConstraint('type', 'number', undefined, true);\n        }\n      // Regular other HTML5 supported types\n      } else if (/^(email|url|range)$/i.test(type)) {\n        return this.addConstraint('type', type, undefined, true);\n      }\n      return this;\n    },\n\n    // Internal only.\n    // Field is required if have required constraint without `false` value\n    _isRequired: function () {\n      if ('undefined' === typeof this.constraintsByName.required)\n        return false;\n\n      return false !== this.constraintsByName.required.requirements;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    _trigger: function (eventName) {\n      return this.trigger('field:' + eventName);\n    },\n\n    // Internal only\n    // Handles whitespace in a value\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n    _handleWhitespace: function (value) {\n      if (true === this.options.trimValue)\n        ParsleyUtils__default.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n      if ('squish' === this.options.whitespace)\n        value = value.replace(/\\s{2,}/g, ' ');\n\n      if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\n        value = ParsleyUtils__default.trimString(value);\n\n      return value;\n    },\n\n    // Internal only.\n    // Returns the constraints, grouped by descending priority.\n    // The result is thus an array of arrays of constraints.\n    _getGroupedConstraints: function () {\n      if (false === this.options.priorityEnabled)\n        return [this.constraints];\n\n      var groupedConstraints = [];\n      var index = {};\n\n      // Create array unique of priorities\n      for (var i = 0; i < this.constraints.length; i++) {\n        var p = this.constraints[i].priority;\n        if (!index[p])\n          groupedConstraints.push(index[p] = []);\n        index[p].push(this.constraints[i]);\n      }\n      // Sort them by priority DESC\n      groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\n\n      return groupedConstraints;\n    }\n\n  };\n\n  var parsley_field = ParsleyField;\n\n  var ParsleyMultiple = function () {\n    this.__class__ = 'ParsleyFieldMultiple';\n  };\n\n  ParsleyMultiple.prototype = {\n    // Add new `$element` sibling for multiple field\n    addElement: function ($element) {\n      this.$elements.push($element);\n\n      return this;\n    },\n\n    // See `ParsleyField.refreshConstraints()`\n    refreshConstraints: function () {\n      var fieldConstraints;\n\n      this.constraints = [];\n\n      // Select multiple special treatment\n      if (this.$element.is('select')) {\n        this.actualizeOptions()._bindConstraints();\n\n        return this;\n      }\n\n      // Gather all constraints for each input in the multiple group\n      for (var i = 0; i < this.$elements.length; i++) {\n\n        // Check if element have not been dynamically removed since last binding\n        if (!$('html').has(this.$elements[i]).length) {\n          this.$elements.splice(i, 1);\n          continue;\n        }\n\n        fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;\n\n        for (var j = 0; j < fieldConstraints.length; j++)\n          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n      }\n\n      return this;\n    },\n\n    // See `ParsleyField.getValue()`\n    getValue: function () {\n      // Value could be overriden in DOM\n      if ('undefined' !== typeof this.options.value)\n        return this.options.value;\n\n      // Radio input case\n      if (this.$element.is('input[type=radio]'))\n        return this._findRelatedMultiple().filter(':checked').val() || '';\n\n      // checkbox input case\n      if (this.$element.is('input[type=checkbox]')) {\n        var values = [];\n\n        this._findRelatedMultiple().filter(':checked').each(function () {\n          values.push($(this).val());\n        });\n\n        return values;\n      }\n\n      // Select multiple case\n      if (this.$element.is('select') && null === this.$element.val())\n        return [];\n\n      // Default case that should never happen\n      return this.$element.val();\n    },\n\n    _init: function () {\n      this.$elements = [this.$element];\n\n      return this;\n    }\n  };\n\n  var ParsleyFactory = function (element, options, parsleyFormInstance) {\n    this.$element = $(element);\n\n    // If the element has already been bound, returns its saved Parsley instance\n    var savedparsleyFormInstance = this.$element.data('Parsley');\n    if (savedparsleyFormInstance) {\n\n      // If the saved instance has been bound without a ParsleyForm parent and there is one given in this call, add it\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n        savedparsleyFormInstance.parent = parsleyFormInstance;\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n      }\n\n      return savedparsleyFormInstance;\n    }\n\n    // Parsley must be instantiated with a DOM element or jQuery $element\n    if (!this.$element.length)\n      throw new Error('You must bind Parsley on an existing element.');\n\n    if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__)\n      throw new Error('Parent instance must be a ParsleyForm instance');\n\n    this.parent = parsleyFormInstance || window.Parsley;\n    return this.init(options);\n  };\n\n  ParsleyFactory.prototype = {\n    init: function (options) {\n      this.__class__ = 'Parsley';\n      this.__version__ = '@@version';\n      this.__id__ = ParsleyUtils__default.generateID();\n\n      // Pre-compute options\n      this._resetOptions(options);\n\n      // A ParsleyForm instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n      if (this.$element.is('form') || (ParsleyUtils__default.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\n        return this.bind('parsleyForm');\n\n      // Every other element is bound as a `ParsleyField` or `ParsleyFieldMultiple`\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n    },\n\n    isMultiple: function () {\n      return (this.$element.is('input[type=radio], input[type=checkbox]')) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));\n    },\n\n    // Multiples fields are a real nightmare :(\n    // Maybe some refactoring would be appreciated here...\n    handleMultiple: function () {\n      var\n        that = this,\n        name,\n        multiple,\n        parsleyMultipleInstance;\n\n      // Handle multiple name\n      if (this.options.multiple)\n        ; // We already have our 'multiple' identifier\n      else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)\n        this.options.multiple = name = this.$element.attr('name');\n      else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)\n        this.options.multiple = this.$element.attr('id');\n\n      // Special select multiple input\n      if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n        this.options.multiple = this.options.multiple || this.__id__;\n        return this.bind('parsleyFieldMultiple');\n\n      // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n      } else if (!this.options.multiple) {\n        ParsleyUtils__default.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n        return this;\n      }\n\n      // Remove special chars\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n      if ('undefined' !== typeof name) {\n        $('input[name=\"' + name + '\"]').each(function () {\n          if ($(this).is('input[type=radio], input[type=checkbox]'))\n            $(this).attr(that.options.namespace + 'multiple', that.options.multiple);\n        });\n      }\n\n      // Check here if we don't already have a related multiple instance saved\n      var $previouslyRelated = this._findRelatedMultiple();\n      for (var i = 0; i < $previouslyRelated.length; i++) {\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n        if ('undefined' !== typeof parsleyMultipleInstance) {\n\n          if (!this.$element.data('ParsleyFieldMultiple')) {\n            parsleyMultipleInstance.addElement(this.$element);\n          }\n\n          break;\n        }\n      }\n\n      // Create a secret ParsleyField instance for every multiple field. It will be stored in `data('ParsleyFieldMultiple')`\n      // And will be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance\n      this.bind('parsleyField', true);\n\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n    },\n\n    // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`\n    bind: function (type, doNotStore) {\n      var parsleyInstance;\n\n      switch (type) {\n        case 'parsleyForm':\n          parsleyInstance = $.extend(\n            new ParsleyForm(this.$element, this.domOptions, this.options),\n            window.ParsleyExtend\n          )._bindFields();\n          break;\n        case 'parsleyField':\n          parsleyInstance = $.extend(\n            new parsley_field(this.$element, this.domOptions, this.options, this.parent),\n            window.ParsleyExtend\n          );\n          break;\n        case 'parsleyFieldMultiple':\n          parsleyInstance = $.extend(\n            new parsley_field(this.$element, this.domOptions, this.options, this.parent),\n            new ParsleyMultiple(),\n            window.ParsleyExtend\n          )._init();\n          break;\n        default:\n          throw new Error(type + 'is not a supported Parsley type');\n      }\n\n      if (this.options.multiple)\n        ParsleyUtils__default.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n      if ('undefined' !== typeof doNotStore) {\n        this.$element.data('ParsleyFieldMultiple', parsleyInstance);\n\n        return parsleyInstance;\n      }\n\n       // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n      this.$element.data('Parsley', parsleyInstance);\n\n      // Tell the world we have a new ParsleyForm or ParsleyField instance!\n      parsleyInstance._trigger('init');\n\n      return parsleyInstance;\n    }\n  };\n\n  var\n    o = $({}),\n    deprecated = function () {\n      ParsleyUtils__default.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n    };\n\n  // Returns an event handler that calls `fn` with the arguments it expects\n  function adapt(fn, context) {\n    // Store to allow unbinding\n    if (!fn.parsleyAdaptedCallback) {\n      fn.parsleyAdaptedCallback = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(this);\n        fn.apply(context || o, args);\n      };\n    }\n    return fn.parsleyAdaptedCallback;\n  }\n\n  var eventPrefix = 'parsley:';\n  // Converts 'parsley:form:validate' into 'form:validate'\n  function eventName(name) {\n    if (name.lastIndexOf(eventPrefix, 0) === 0)\n      return name.substr(eventPrefix.length);\n    return name;\n  }\n\n  // $.listen is deprecated. Use Parsley.on instead.\n  $.listen = function (name, callback) {\n    var context;\n    deprecated();\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n      context = arguments[1];\n      callback = arguments[2];\n    }\n\n    if ('function' !== typeof callback)\n      throw new Error('Wrong parameters');\n\n    window.Parsley.on(eventName(name), adapt(callback, context));\n  };\n\n  $.listenTo = function (instance, name, fn) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm))\n      throw new Error('Must give Parsley instance');\n\n    if ('string' !== typeof name || 'function' !== typeof fn)\n      throw new Error('Wrong parameters');\n\n    instance.on(eventName(name), adapt(fn));\n  };\n\n  $.unsubscribe = function (name, fn) {\n    deprecated();\n    if ('string' !== typeof name || 'function' !== typeof fn)\n      throw new Error('Wrong arguments');\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n  };\n\n  $.unsubscribeTo = function (instance, name) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm))\n      throw new Error('Must give Parsley instance');\n    instance.off(eventName(name));\n  };\n\n  $.unsubscribeAll = function (name) {\n    deprecated();\n    window.Parsley.off(eventName(name));\n    $('form,input,textarea,select').each(function() {\n      var instance = $(this).data('Parsley');\n      if (instance) {\n        instance.off(eventName(name));\n      }\n    });\n  };\n\n  // $.emit is deprecated. Use jQuery events instead.\n  $.emit = function (name, instance) {\n    deprecated();\n    var instanceGiven = (instance instanceof parsley_field) || (instance instanceof ParsleyForm);\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n    args.unshift(eventName(name));\n    if (!instanceGiven) {\n      instance = window.Parsley;\n    }\n    instance.trigger.apply(instance, args);\n  };\n\n  var PubSub = {};\n\n  //     Parsley.js @@version\n  //     http://parsleyjs.org\n  //     (c) 2012-2015 Guillaume Potier, Wisembly\n  //     Parsley may be freely distributed under the MIT license.\n\n  // import i18nEN from 'i18n/en';\n\n  // Inherit `on`, `off` & `trigger` to Parsley:\n  var parsley__Parsley = $.extend(new ParsleyAbstract(), {\n      $element: $(document),\n      actualizeOptions: null,\n      _resetOptions: null,\n      Factory: ParsleyFactory,\n      version: '@@version'\n    });\n\n  // Supplement ParsleyField and Form with ParsleyAbstract\n  // This way, the constructors will have access to those methods\n  $.extend(parsley_field.prototype, ParsleyAbstract.prototype);\n  $.extend(ParsleyForm.prototype, ParsleyAbstract.prototype);\n  // Inherit actualizeOptions and _resetOptions:\n  $.extend(ParsleyFactory.prototype, ParsleyAbstract.prototype);\n\n  // ### jQuery API\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n  $.fn.parsley = $.fn.psly = function (options) {\n    if (this.length > 1) {\n      var instances = [];\n\n      this.each(function () {\n        instances.push($(this).parsley(options));\n      });\n\n      return instances;\n    }\n\n    // Return undefined if applied to non existing DOM element\n    if (!$(this).length) {\n      ParsleyUtils__default.warn('You must bind Parsley on an existing element.');\n\n      return;\n    }\n\n    return new ParsleyFactory(this, options);\n  };\n\n  // ### ParsleyField and ParsleyForm extension\n  // Ensure the extension is now defined if it wasn't previously\n  if ('undefined' === typeof window.ParsleyExtend)\n    window.ParsleyExtend = {};\n\n  // ### Parsley config\n  // Inherit from ParsleyDefault, and copy over any existing values\n  parsley__Parsley.options = $.extend(ParsleyUtils__default.objectCreate(ParsleyDefaults), window.ParsleyConfig);\n  window.ParsleyConfig = parsley__Parsley.options; // Old way of accessing global options\n\n  // ### Globals\n  window.Parsley = window.psly = parsley__Parsley;\n  window.ParsleyUtils = ParsleyUtils__default;\n\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\n  var registry = window.Parsley._validatorRegistry = new ParsleyValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\n  window.ParsleyValidator = {};\n  $.each('setLocale addCatalog addMessage getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n    window.Parsley[method] = $.proxy(registry, method);\n    window.ParsleyValidator[method] = function () {\n      ParsleyUtils__default.warnOnce('Accessing the method `'+ method +'` through ParsleyValidator is deprecated. Simply call `window.Parsley.' + method + '(...)`');\n      return window.Parsley[method].apply(window.Parsley, arguments);\n    };\n  });\n\n  // ### ParsleyUI\n  // UI is a separate class that only listens to some events and then modifies the DOM accordingly\n  // Could be overriden by defining a `window.ParsleyConfig.ParsleyUI` appropriate class (with `listen()` method basically)\n  window.ParsleyUI = 'function' === typeof window.ParsleyConfig.ParsleyUI ?\n    new window.ParsleyConfig.ParsleyUI().listen() : new ParsleyUI().listen();\n\n  // ### PARSLEY auto-binding\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\n  if (false !== window.ParsleyConfig.autoBind) {\n    $(function () {\n      // Works only on `data-parsley-validate`.\n      if ($('[data-parsley-validate]').length)\n        $('[data-parsley-validate]').parsley();\n    });\n  }\n\n  var parsley = parsley__Parsley;\n\n  return parsley;\n\n}));\n","import ParsleyField from 'parsley/field';\nimport ParsleyForm from 'parsley/form';\nimport ParsleyUtils from 'parsley/utils';\n\nvar\n  o = $({}),\n  deprecated = function () {\n    ParsleyUtils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n  };\n\n// Returns an event handler that calls `fn` with the arguments it expects\nfunction adapt(fn, context) {\n  // Store to allow unbinding\n  if (!fn.parsleyAdaptedCallback) {\n    fn.parsleyAdaptedCallback = function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(this);\n      fn.apply(context || o, args);\n    };\n  }\n  return fn.parsleyAdaptedCallback;\n}\n\nvar eventPrefix = 'parsley:';\n// Converts 'parsley:form:validate' into 'form:validate'\nfunction eventName(name) {\n  if (name.lastIndexOf(eventPrefix, 0) === 0)\n    return name.substr(eventPrefix.length);\n  return name;\n}\n\n// $.listen is deprecated. Use Parsley.on instead.\n$.listen = function (name, callback) {\n  var context;\n  deprecated();\n  if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n    context = arguments[1];\n    callback = arguments[2];\n  }\n\n  if ('function' !== typeof callback)\n    throw new Error('Wrong parameters');\n\n  window.Parsley.on(eventName(name), adapt(callback, context));\n};\n\n$.listenTo = function (instance, name, fn) {\n  deprecated();\n  if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))\n    throw new Error('Must give Parsley instance');\n\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong parameters');\n\n  instance.on(eventName(name), adapt(fn));\n};\n\n$.unsubscribe = function (name, fn) {\n  deprecated();\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong arguments');\n  window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n};\n\n$.unsubscribeTo = function (instance, name) {\n  deprecated();\n  if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))\n    throw new Error('Must give Parsley instance');\n  instance.off(eventName(name));\n};\n\n$.unsubscribeAll = function (name) {\n  deprecated();\n  window.Parsley.off(eventName(name));\n  $('form,input,textarea,select').each(function() {\n    var instance = $(this).data('Parsley');\n    if (instance) {\n      instance.off(eventName(name));\n    }\n  });\n};\n\n// $.emit is deprecated. Use jQuery events instead.\n$.emit = function (name, instance) {\n  deprecated();\n  var instanceGiven = (instance instanceof ParsleyField) || (instance instanceof ParsleyForm);\n  var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n  args.unshift(eventName(name));\n  if (!instanceGiven) {\n    instance = window.Parsley;\n  }\n  instance.trigger.apply(instance, args);\n};\n\nexport default {};\n","var globalID = 1,\n  pastWarnings = {};\n\nvar ParsleyUtils = {\n  // Parsley DOM-API\n  // returns object from dom attributes and values\n  attr: function ($element, namespace, obj) {\n    var\n      i, attribute, attributes,\n      regex = new RegExp('^' + namespace, 'i');\n\n    if ('undefined' === typeof obj)\n      obj = {};\n    else {\n      // Clear all own properties. This won't affect prototype's values\n      for (i in obj) {\n        if (obj.hasOwnProperty(i))\n          delete obj[i];\n      }\n    }\n\n    if ('undefined' === typeof $element || 'undefined' === typeof $element[0])\n      return obj;\n\n    attributes = $element[0].attributes;\n    for (i = attributes.length; i--; ) {\n      attribute = attributes[i];\n\n      if (attribute && attribute.specified && regex.test(attribute.name)) {\n        obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n      }\n    }\n\n    return obj;\n  },\n\n  checkAttr: function ($element, namespace, checkAttr) {\n    return $element.is('[' + namespace + checkAttr + ']');\n  },\n\n  setAttr: function ($element, namespace, attr, value) {\n    $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n  },\n\n  generateID: function () {\n    return '' + globalID++;\n  },\n\n  /** Third party functions **/\n  // Zepto deserialize function\n  deserializeValue: function (value) {\n    var num;\n\n    try {\n      return value ?\n        value == \"true\" ||\n        (value == \"false\" ? false :\n        value == \"null\" ? null :\n        !isNaN(num = Number(value)) ? num :\n        /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n        value)\n        : value;\n    } catch (e) { return value; }\n  },\n\n  // Zepto camelize function\n  camelize: function (str) {\n    return str.replace(/-+(.)?/g, function (match, chr) {\n      return chr ? chr.toUpperCase() : '';\n    });\n  },\n\n  // Zepto dasherize function\n  dasherize: function (str) {\n    return str.replace(/::/g, '/')\n      .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n      .replace(/_/g, '-')\n      .toLowerCase();\n  },\n\n  warn: function() {\n    if (window.console && 'function' === typeof window.console.warn)\n      window.console.warn.apply(window.console, arguments);\n  },\n\n  warnOnce: function(msg) {\n    if (!pastWarnings[msg]) {\n      pastWarnings[msg] = true;\n      this.warn.apply(this, arguments);\n    }\n  },\n\n  _resetWarnings: function() {\n    pastWarnings = {};\n  },\n\n  trimString: function(string) {\n    return string.replace(/^\\s+|\\s+$/g, '');\n  },\n\n  // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n  objectCreate: Object.create || (function () {\n    var Object = function () {};\n    return function (prototype) {\n      if (arguments.length > 1) {\n        throw Error('Second argument not supported');\n      }\n      if (typeof prototype != 'object') {\n        throw TypeError('Argument must be an object');\n      }\n      Object.prototype = prototype;\n      var result = new Object();\n      Object.prototype = null;\n      return result;\n    };\n  })()\n};\n\nexport default ParsleyUtils;\n","// All these options could be overriden and specified directly in DOM using\n// `data-parsley-` default DOM-API\n// eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n// eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\nvar ParsleyDefaults = {\n  // ### General\n\n  // Default data-namespace for DOM API\n  namespace: 'data-parsley-',\n\n  // Supported inputs by default\n  inputs: 'input, textarea, select',\n\n  // Excluded inputs by default\n  excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n  // Stop validating field on highest priority failing constraint\n  priorityEnabled: true,\n\n  // ### Field only\n\n  // identifier used to group together inputs (e.g. radio buttons...)\n  multiple: null,\n\n  // identifier (or array of identifiers) used to validate only a select group of inputs\n  group: null,\n\n  // ### UI\n  // Enable\\Disable error messages\n  uiEnabled: true,\n\n  // Key events threshold before validation\n  validationThreshold: 3,\n\n  // Focused field on form validation error. 'first'|'last'|'none'\n  focus: 'first',\n\n  // `$.Event()` that will trigger validation. eg: `keyup`, `change`...\n  trigger: false,\n\n  // Class that would be added on every failing validation Parsley field\n  errorClass: 'parsley-error',\n\n  // Same for success validation\n  successClass: 'parsley-success',\n\n  // Return the `$element` that will receive these above success or error classes\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  classHandler: function (ParsleyField) {},\n\n  // Return the `$element` where errors will be appended\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  errorsContainer: function (ParsleyField) {},\n\n  // ul elem that would receive errors' list\n  errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n  // li elem that would receive error message\n  errorTemplate: '<li></li>'\n};\n\nexport default ParsleyDefaults;\n","import ParsleyUtils from 'parsley/utils';\n\nvar ParsleyAbstract = function () {};\n\nParsleyAbstract.prototype = {\n  asyncSupport: true, // Deprecated\n\n  actualizeOptions: function () {\n    ParsleyUtils.attr(this.$element, this.options.namespace, this.domOptions);\n    if (this.parent && this.parent.actualizeOptions)\n      this.parent.actualizeOptions();\n    return this;\n  },\n\n  _resetOptions: function (initOptions) {\n    this.domOptions = ParsleyUtils.objectCreate(this.parent.options);\n    this.options = ParsleyUtils.objectCreate(this.domOptions);\n    // Shallow copy of ownProperties of initOptions:\n    for (var i in initOptions) {\n      if (initOptions.hasOwnProperty(i))\n        this.options[i] = initOptions[i];\n    }\n    this.actualizeOptions();\n  },\n\n  _listeners: null,\n\n  // Register a callback for the given event name.\n  // Callback is called with context as the first argument and the `this`.\n  // The context is the current parsley instance, or window.Parsley if global.\n  // A return value of `false` will interrupt the calls\n  on: function (name, fn) {\n    this._listeners = this._listeners || {};\n    var queue = this._listeners[name] = this._listeners[name] || [];\n    queue.push(fn);\n\n    return this;\n  },\n\n  // Deprecated. Use `on` instead.\n  subscribe: function(name, fn) {\n    $.listenTo(this, name.toLowerCase(), fn);\n  },\n\n  // Unregister a callback (or all if none is given) for the given event name\n  off: function (name, fn) {\n    var queue = this._listeners && this._listeners[name];\n    if (queue) {\n      if (!fn) {\n        delete this._listeners[name];\n      } else {\n        for(var i = queue.length; i--; )\n          if (queue[i] === fn)\n            queue.splice(i, 1);\n      }\n    }\n    return this;\n  },\n\n  // Deprecated. Use `off`\n  unsubscribe: function(name, fn) {\n    $.unsubscribeTo(this, name.toLowerCase());\n  },\n\n  // Trigger an event of the given name.\n  // A return value of `false` interrupts the callback chain.\n  // Returns false if execution was interrupted.\n  trigger: function (name, target, extraArg) {\n    target = target || this;\n    var queue = this._listeners && this._listeners[name];\n    var result, parentResult;\n    if (queue) {\n      for(var i = queue.length; i--; ) {\n        result = queue[i].call(target, target, extraArg);\n        if (result === false) return result;\n      }\n    }\n    if (this.parent) {\n      return this.parent.trigger(name, target, extraArg);\n    }\n    return true;\n  },\n\n  // Reset UI\n  reset: function () {\n    // Field case: just emit a reset event for UI\n    if ('ParsleyForm' !== this.__class__)\n      return this._trigger('reset');\n\n    // Form case: emit a reset event for each field\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i]._trigger('reset');\n\n    this._trigger('reset');\n  },\n\n  // Destroy Parsley instance (+ UI)\n  destroy: function () {\n    // Field case: emit destroy event to clean UI and then destroy stored instance\n    if ('ParsleyForm' !== this.__class__) {\n      this.$element.removeData('Parsley');\n      this.$element.removeData('ParsleyFieldMultiple');\n      this._trigger('destroy');\n\n      return;\n    }\n\n    // Form case: destroy all its fields and then destroy stored instance\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i].destroy();\n\n    this.$element.removeData('Parsley');\n    this._trigger('destroy');\n  },\n\n  asyncIsValid: function() {\n    ParsleyUtils.warnOnce(\"asyncIsValid is deprecated; please use whenIsValid instead\");\n    return this.whenValid.apply(this, arguments);\n  },\n\n  _findRelatedMultiple: function() {\n    return this.parent.$element.find('[' + this.options.namespace + 'multiple=\"' + this.options.multiple +'\"]');\n  }\n};\n\nexport default ParsleyAbstract;\n","import ParsleyUtils from 'parsley/utils';\n\nvar requirementConverters = {\n  string: function(string) {\n    return string;\n  },\n  integer: function(string) {\n    if (isNaN(string))\n      throw 'Requirement is not an integer: \"' + string + '\"';\n    return parseInt(string, 10);\n  },\n  number: function(string) {\n    if (isNaN(string))\n      throw 'Requirement is not a number: \"' + string + '\"';\n    return parseFloat(string);\n  },\n  reference: function(string) { // Unused for now\n    var result = $(string);\n    if (result.length === 0)\n      throw 'No such reference: \"' + string + '\"';\n    return result;\n  },\n  boolean: function(string) {\n    return string !== 'false';\n  },\n  object: function(string) {\n    return ParsleyUtils.deserializeValue(string);\n  },\n  regexp: function(regexp) {\n    var flags = '';\n\n    // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n    if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\n      // Replace the regexp literal string with the first match group: ([gimy]*)\n      // If no flag is present, this will be a blank string\n      flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\n      // Again, replace the regexp literal string with the first match group:\n      // everything excluding the opening and closing slashes and the flags\n      regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n    } else {\n      // Anchor regexp:\n      regexp = '^' + regexp + '$';\n    }\n    return new RegExp(regexp, flags);\n  }\n};\n\nvar convertArrayRequirement = function(string, length) {\n  var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n  if (!m)\n    throw 'Requirement is not an array: \"' + string + '\"';\n  var values = m[1].split(',').map(ParsleyUtils.trimString);\n  if (values.length !== length)\n    throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n  return values;\n};\n\nvar convertRequirement = function(requirementType, string) {\n  var converter = requirementConverters[requirementType || 'string'];\n  if (!converter)\n    throw 'Unknown requirement specification: \"' + requirementType + '\"';\n  return converter(string);\n};\n\nvar convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\n  var main = null, extra = {};\n  for(var key in requirementSpec) {\n    if (key) {\n      var value = extraOptionReader(key);\n      if('string' === typeof value)\n        value = convertRequirement(requirementSpec[key], value);\n      extra[key] = value;\n    } else {\n      main = convertRequirement(requirementSpec[key], string);\n    }\n  }\n  return [main, extra];\n};\n\n// A Validator needs to implement the methods `validate` and `parseRequirements`\n\nvar ParsleyValidator = function(spec) {\n  $.extend(true, this, spec);\n};\n\nParsleyValidator.prototype = {\n  // Returns `true` iff the given `value` is valid according the given requirements.\n  validate: function(value, requirementFirstArg) {\n    if(this.fn) { // Legacy style validator\n\n      if(arguments.length > 3)  // If more args then value, requirement, instance...\n        requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\n      return this.fn.call(this, value, requirementFirstArg);\n    }\n\n    if ($.isArray(value)) {\n      if (!this.validateMultiple)\n        throw 'Validator `' + this.name + '` does not handle multiple values';\n      return this.validateMultiple.apply(this, arguments);\n    } else {\n      if (this.validateNumber) {\n        if (isNaN(value))\n          return false;\n        arguments[0] = parseFloat(arguments[0]);\n        return this.validateNumber.apply(this, arguments);\n      }\n      if (this.validateString) {\n        return this.validateString.apply(this, arguments);\n      }\n      throw 'Validator `' + this.name + '` only handles multiple values';\n    }\n  },\n\n  // Parses `requirements` into an array of arguments,\n  // according to `this.requirementType`\n  parseRequirements: function(requirements, extraOptionReader) {\n    if ('string' !== typeof requirements) {\n      // Assume requirement already parsed\n      // but make sure we return an array\n      return $.isArray(requirements) ? requirements : [requirements];\n    }\n    var type = this.requirementType;\n    if ($.isArray(type)) {\n      var values = convertArrayRequirement(requirements, type.length);\n      for (var i = 0; i < values.length; i++)\n        values[i] = convertRequirement(type[i], values[i]);\n      return values;\n    } else if ($.isPlainObject(type)) {\n      return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n    } else {\n      return [convertRequirement(type, requirements)];\n    }\n  },\n  // Defaults:\n  requirementType: 'string',\n\n  priority: 2\n\n};\n\nexport default ParsleyValidator;\n","import ParsleyDefaults from 'parsley/defaults';\nimport ParsleyValidator from 'parsley/validator';\n\nvar ParsleyValidatorRegistry = function (validators, catalog) {\n  this.__class__ = 'ParsleyValidatorRegistry';\n\n  // Default Parsley locale is en\n  this.locale = 'en';\n\n  this.init(validators || {}, catalog || {});\n};\n\nvar typeRegexes =  {\n  email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n  number: /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/,\n\n  integer: /^-?\\d+$/,\n\n  digits: /^\\d+$/,\n\n  alphanum: /^\\w+$/i,\n\n  url: new RegExp(\n      \"^\" +\n        // protocol identifier\n        \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\" +\n          // IP address exclusion\n          // private & local networks\n          // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n          // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          // TLD identifier\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:/\\\\S*)?\" +\n      \"$\", 'i'\n    )\n};\ntypeRegexes.range = typeRegexes.number;\n\nParsleyValidatorRegistry.prototype = {\n  init: function (validators, catalog) {\n    this.catalog = catalog;\n    // Copy prototype's validators:\n    this.validators = $.extend({}, this.validators);\n\n    for (var name in validators)\n      this.addValidator(name, validators[name].fn, validators[name].priority);\n\n    window.Parsley.trigger('parsley:validator:init');\n  },\n\n  // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n  setLocale: function (locale) {\n    if ('undefined' === typeof this.catalog[locale])\n      throw new Error(locale + ' is not available in the catalog');\n\n    this.locale = locale;\n\n    return this;\n  },\n\n  // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n  addCatalog: function (locale, messages, set) {\n    if ('object' === typeof messages)\n      this.catalog[locale] = messages;\n\n    if (true === set)\n      return this.setLocale(locale);\n\n    return this;\n  },\n\n  // Add a specific message for a given constraint in a given locale\n  addMessage: function (locale, name, message) {\n    if ('undefined' === typeof this.catalog[locale])\n      this.catalog[locale] = {};\n\n    this.catalog[locale][name.toLowerCase()] = message;\n\n    return this;\n  },\n\n  // Add a new validator\n  //\n  //    addValidator('custom', {\n  //        requirementType: ['integer', 'integer'],\n  //        validateString: function(value, from, to) {},\n  //        priority: 22,\n  //        messages: {\n  //          en: \"Hey, that's no good\",\n  //          fr: \"Aye aye, pas bon du tout\",\n  //        }\n  //    })\n  //\n  // Old API was addValidator(name, function, priority)\n  //\n  addValidator: function (name, arg1, arg2) {\n    if (this.validators[name])\n      ParsleyUtils.warn('Validator \"' + name + '\" is already defined.');\n    else if (ParsleyDefaults.hasOwnProperty(name)) {\n      ParsleyUtils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n      return;\n    }\n    return this._setValidator.apply(this, arguments);\n  },\n\n  updateValidator: function (name, arg1, arg2) {\n    if (!this.validators[name]) {\n      ParsleyUtils.warn('Validator \"' + name + '\" is not already defined.');\n      return this.addValidator.apply(this, arguments);\n    }\n    return this._setValidator(this, arguments);\n  },\n\n  removeValidator: function (name) {\n    if (!this.validators[name])\n      ParsleyUtils.warn('Validator \"' + name + '\" is not defined.');\n\n    delete this.validators[name];\n\n    return this;\n  },\n\n  _setValidator: function (name, validator, priority) {\n    if ('object' !== typeof validator) {\n      // Old style validator, with `fn` and `priority`\n      validator = {\n        fn: validator,\n        priority: priority\n      };\n    }\n    if (!validator.validate) {\n      validator = new ParsleyValidator(validator);\n    }\n    this.validators[name] = validator;\n\n    for (var locale in validator.messages || {})\n      this.addMessage(locale, name, validator.messages[locale]);\n\n    return this;\n  },\n\n  getErrorMessage: function (constraint) {\n    var message;\n\n    // Type constraints are a bit different, we have to match their requirements too to find right error message\n    if ('type' === constraint.name) {\n      var typeMessages = this.catalog[this.locale][constraint.name] || {};\n      message = typeMessages[constraint.requirements];\n    } else\n      message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n    return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n  },\n\n  // Kind of light `sprintf()` implementation\n  formatMessage: function (string, parameters) {\n    if ('object' === typeof parameters) {\n      for (var i in parameters)\n        string = this.formatMessage(string, parameters[i]);\n\n      return string;\n    }\n\n    return 'string' === typeof string ? string.replace(new RegExp('%s', 'i'), parameters) : '';\n  },\n\n  // Here is the Parsley default validators list.\n  // A validator is an object with the following key values:\n  //  - priority: an integer\n  //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n  //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n  // Alternatively, a validator can be a function that returns such an object\n  //\n  validators: {\n    notblank: {\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 2\n    },\n    required: {\n      validateMultiple: function(values) {\n        return values.length > 0;\n      },\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 512\n    },\n    type: {\n      validateString: function(value, type) {\n        var regex = typeRegexes[type];\n        if (!regex)\n          throw new Error('validator type `' + type + '` is not supported');\n        return regex.test(value);\n      },\n      priority: 256\n    },\n    pattern: {\n      validateString: function(value, regexp) {\n        return regexp.test(value);\n      },\n      requirementType: 'regexp',\n      priority: 64\n    },\n    minlength: {\n      validateString: function (value, requirement) {\n        return value.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxlength: {\n      validateString: function (value, requirement) {\n        return value.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    length: {\n      validateString: function (value, min, max) {\n        return value.length >= min && value.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    mincheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxcheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    check: {\n      validateMultiple: function (values, min, max) {\n        return values.length >= min && values.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    min: {\n      validateNumber: function (value, requirement) {\n        return value >= requirement;\n      },\n      requirementType: 'number',\n      priority: 30\n    },\n    max: {\n      validateNumber: function (value, requirement) {\n        return value <= requirement;\n      },\n      requirementType: 'number',\n      priority: 30\n    },\n    range: {\n      validateNumber: function (value, min, max) {\n        return value >= min && value <= max;\n      },\n      requirementType: ['number', 'number'],\n      priority: 30\n    },\n    equalto: {\n      validateString: function (value, refOrValue) {\n        var $reference = $(refOrValue);\n        if ($reference.length)\n          return value === $reference.val();\n        else\n          return value === refOrValue;\n      },\n      priority: 256\n    }\n  }\n};\n\nexport default ParsleyValidatorRegistry;\n","import ParsleyUtils from 'parsley/utils';\n\nvar ParsleyUI = function (options) {\n  this.__class__ = 'ParsleyUI';\n};\n\nParsleyUI.prototype = {\n  listen: function () {\n    var that = this;\n    window.Parsley\n    .on('form:init',       function () { that.setupForm (this); } )\n    .on('field:init',      function () { that.setupField(this); } )\n    .on('field:validated', function () { that.reflow    (this); } )\n    .on('form:validated',  function () { that.focus     (this); } )\n    .on('field:reset',     function () { that.reset     (this); } )\n    .on('form:destroy',    function () { that.destroy   (this); } )\n    .on('field:destroy',   function () { that.destroy   (this); } );\n\n    return this;\n  },\n\n  reflow: function (fieldInstance) {\n    // If this field has not an active UI (case for multiples) don't bother doing something\n    if ('undefined' === typeof fieldInstance._ui || false === fieldInstance._ui.active)\n      return;\n\n    // Diff between two validation results\n    var diff = this._diff(fieldInstance.validationResult, fieldInstance._ui.lastValidationResult);\n\n    // Then store current validation result for next reflow\n    fieldInstance._ui.lastValidationResult = fieldInstance.validationResult;\n\n    // Field have been validated at least once if here. Useful for binded key events...\n    fieldInstance._ui.validatedOnce = true;\n\n    // Handle valid / invalid / none field class\n    this.manageStatusClass(fieldInstance);\n\n    // Add, remove, updated errors messages\n    this.manageErrorsMessages(fieldInstance, diff);\n\n    // Triggers impl\n    this.actualizeTriggers(fieldInstance);\n\n    // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n    if ((diff.kept.length || diff.added.length) && true !== fieldInstance._ui.failedOnce)\n      this.manageFailingFieldTrigger(fieldInstance);\n  },\n\n  // Returns an array of field's error message(s)\n  getErrorsMessages: function (fieldInstance) {\n    // No error message, field is valid\n    if (true === fieldInstance.validationResult)\n      return [];\n\n    var messages = [];\n\n    for (var i = 0; i < fieldInstance.validationResult.length; i++)\n      messages.push(this._getErrorMessage(fieldInstance, fieldInstance.validationResult[i].assert));\n\n    return messages;\n  },\n\n  manageStatusClass: function (fieldInstance) {\n    if (fieldInstance.hasConstraints() && fieldInstance.needsValidation() && true === fieldInstance.validationResult)\n      this._successClass(fieldInstance);\n    else if (fieldInstance.validationResult.length > 0)\n      this._errorClass(fieldInstance);\n    else\n      this._resetClass(fieldInstance);\n  },\n\n  manageErrorsMessages: function (fieldInstance, diff) {\n    if ('undefined' !== typeof fieldInstance.options.errorsMessagesDisabled)\n      return;\n\n    // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n    if ('undefined' !== typeof fieldInstance.options.errorMessage) {\n      if ((diff.added.length || diff.kept.length)) {\n        this._insertErrorWrapper(fieldInstance);\n\n        if (0 === fieldInstance._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\n          fieldInstance._ui.$errorsWrapper\n            .append(\n              $(fieldInstance.options.errorTemplate)\n              .addClass('parsley-custom-error-message')\n            );\n\n        return fieldInstance._ui.$errorsWrapper\n          .addClass('filled')\n          .find('.parsley-custom-error-message')\n          .html(fieldInstance.options.errorMessage);\n      }\n\n      return fieldInstance._ui.$errorsWrapper\n        .removeClass('filled')\n        .find('.parsley-custom-error-message')\n        .remove();\n    }\n\n    // Show, hide, update failing constraints messages\n    for (var i = 0; i < diff.removed.length; i++)\n      this.removeError(fieldInstance, diff.removed[i].assert.name, true);\n\n    for (i = 0; i < diff.added.length; i++)\n      this.addError(fieldInstance, diff.added[i].assert.name, undefined, diff.added[i].assert, true);\n\n    for (i = 0; i < diff.kept.length; i++)\n      this.updateError(fieldInstance, diff.kept[i].assert.name, undefined, diff.kept[i].assert, true);\n  },\n\n  // TODO: strange API here, intuitive for manual usage with addError(pslyInstance, 'foo', 'bar')\n  // but a little bit complex for above internal usage, with forced undefined parameter...\n  addError: function (fieldInstance, name, message, assert, doNotUpdateClass) {\n    this._insertErrorWrapper(fieldInstance);\n    fieldInstance._ui.$errorsWrapper\n      .addClass('filled')\n      .append(\n        $(fieldInstance.options.errorTemplate)\n        .addClass('parsley-' + name)\n        .html(message || this._getErrorMessage(fieldInstance, assert))\n      );\n\n    if (true !== doNotUpdateClass)\n      this._errorClass(fieldInstance);\n  },\n\n  // Same as above\n  updateError: function (fieldInstance, name, message, assert, doNotUpdateClass) {\n    fieldInstance._ui.$errorsWrapper\n      .addClass('filled')\n      .find('.parsley-' + name)\n      .html(message || this._getErrorMessage(fieldInstance, assert));\n\n    if (true !== doNotUpdateClass)\n      this._errorClass(fieldInstance);\n  },\n\n  // Same as above twice\n  removeError: function (fieldInstance, name, doNotUpdateClass) {\n    fieldInstance._ui.$errorsWrapper\n      .removeClass('filled')\n      .find('.parsley-' + name)\n      .remove();\n\n    // edge case possible here: remove a standard Parsley error that is still failing in fieldInstance.validationResult\n    // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n    if (true !== doNotUpdateClass)\n      this.manageStatusClass(fieldInstance);\n  },\n\n  focus: function (formInstance) {\n    formInstance._focusedField = null;\n\n    if (true === formInstance.validationResult || 'none' === formInstance.options.focus)\n      return null;\n\n    for (var i = 0; i < formInstance.fields.length; i++) {\n      var field = formInstance.fields[i];\n      if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n        formInstance._focusedField = field.$element;\n        if ('first' === formInstance.options.focus)\n          break;\n      }\n    }\n\n    if (null === formInstance._focusedField)\n      return null;\n\n    return formInstance._focusedField.focus();\n  },\n\n  _getErrorMessage: function (fieldInstance, constraint) {\n    var customConstraintErrorMessage = constraint.name + 'Message';\n\n    if ('undefined' !== typeof fieldInstance.options[customConstraintErrorMessage])\n      return window.Parsley.formatMessage(fieldInstance.options[customConstraintErrorMessage], constraint.requirements);\n\n    return window.Parsley.getErrorMessage(constraint);\n  },\n\n  _diff: function (newResult, oldResult, deep) {\n    var\n      added = [],\n      kept = [];\n\n    for (var i = 0; i < newResult.length; i++) {\n      var found = false;\n\n      for (var j = 0; j < oldResult.length; j++)\n        if (newResult[i].assert.name === oldResult[j].assert.name) {\n          found = true;\n          break;\n        }\n\n      if (found)\n        kept.push(newResult[i]);\n      else\n        added.push(newResult[i]);\n    }\n\n    return {\n      kept: kept,\n      added: added,\n      removed: !deep ? this._diff(oldResult, newResult, true).added : []\n    };\n  },\n\n  setupForm: function (formInstance) {\n    formInstance.$element.on('submit.Parsley', false, $.proxy(formInstance.onSubmitValidate, formInstance));\n\n    // UI could be disabled\n    if (false === formInstance.options.uiEnabled)\n      return;\n\n    formInstance.$element.attr('novalidate', '');\n  },\n\n  setupField: function (fieldInstance) {\n    var _ui = { active: false };\n\n    // UI could be disabled\n    if (false === fieldInstance.options.uiEnabled)\n      return;\n\n    _ui.active = true;\n\n    // Give field its Parsley id in DOM\n    fieldInstance.$element.attr(fieldInstance.options.namespace + 'id', fieldInstance.__id__);\n\n    /** Generate important UI elements and store them in fieldInstance **/\n    // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n    _ui.$errorClassHandler = this._manageClassHandler(fieldInstance);\n\n    // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n    _ui.errorsWrapperId = 'parsley-id-' + (fieldInstance.options.multiple ? 'multiple-' + fieldInstance.options.multiple : fieldInstance.__id__);\n    _ui.$errorsWrapper = $(fieldInstance.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n    // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n    _ui.lastValidationResult = [];\n    _ui.validatedOnce = false;\n    _ui.validationInformationVisible = false;\n\n    // Store it in fieldInstance for later\n    fieldInstance._ui = _ui;\n\n    // Bind triggers first time\n    this.actualizeTriggers(fieldInstance);\n  },\n\n  // Determine which element will have `parsley-error` and `parsley-success` classes\n  _manageClassHandler: function (fieldInstance) {\n    // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n    if ('string' === typeof fieldInstance.options.classHandler && $(fieldInstance.options.classHandler).length)\n      return $(fieldInstance.options.classHandler);\n\n    // Class handled could also be determined by function given in Parsley options\n    var $handler = fieldInstance.options.classHandler(fieldInstance);\n\n    // If this function returned a valid existing DOM element, go for it\n    if ('undefined' !== typeof $handler && $handler.length)\n      return $handler;\n\n    // Otherwise, if simple element (input, texatrea, select...) it will perfectly host the classes\n    if (!fieldInstance.options.multiple || fieldInstance.$element.is('select'))\n      return fieldInstance.$element;\n\n    // But if multiple element (radio, checkbox), that would be their parent\n    return fieldInstance.$element.parent();\n  },\n\n  _insertErrorWrapper: function (fieldInstance) {\n    var $errorsContainer;\n\n    // Nothing to do if already inserted\n    if (0 !== fieldInstance._ui.$errorsWrapper.parent().length)\n      return fieldInstance._ui.$errorsWrapper.parent();\n\n    if ('string' === typeof fieldInstance.options.errorsContainer) {\n      if ($(fieldInstance.options.errorsContainer).length)\n        return $(fieldInstance.options.errorsContainer).append(fieldInstance._ui.$errorsWrapper);\n      else\n        ParsleyUtils.warn('The errors container `' + fieldInstance.options.errorsContainer + '` does not exist in DOM');\n    }\n    else if ('function' === typeof fieldInstance.options.errorsContainer)\n      $errorsContainer = fieldInstance.options.errorsContainer(fieldInstance);\n\n    if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\n      return $errorsContainer.append(fieldInstance._ui.$errorsWrapper);\n\n    var $from = fieldInstance.$element;\n    if (fieldInstance.options.multiple)\n      $from = $from.parent();\n    return $from.after(fieldInstance._ui.$errorsWrapper);\n  },\n\n  actualizeTriggers: function (fieldInstance) {\n    var $toBind = fieldInstance.$element;\n    if (fieldInstance.options.multiple)\n      $toBind = $('[' + fieldInstance.options.namespace + 'multiple=\"' + fieldInstance.options.multiple + '\"]');\n\n    // Remove Parsley events already binded on this field\n    $toBind.off('.Parsley');\n\n    // If no trigger is set, all good\n    if (false === fieldInstance.options.trigger)\n      return;\n\n    var triggers = fieldInstance.options.trigger.replace(/^\\s+/g , '').replace(/\\s+$/g , '');\n\n    if ('' === triggers)\n      return;\n\n    // Bind fieldInstance.eventValidate if exists (for parsley.ajax for example), ParsleyUI.eventValidate otherwise\n    $toBind.on(\n      triggers.split(' ').join('.Parsley ') + '.Parsley',\n      $.proxy('function' === typeof fieldInstance.eventValidate ? fieldInstance.eventValidate : this.eventValidate, fieldInstance));\n  },\n\n  // Called through $.proxy with fieldInstance. `this` context is ParsleyField\n  eventValidate: function (event) {\n    // For keyup, keypress, keydown... events that could be a little bit obstrusive\n    // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n    // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n    if (new RegExp('key').test(event.type))\n      if (!this._ui.validationInformationVisible && this.getValue().length <= this.options.validationThreshold)\n        return;\n\n    this._ui.validatedOnce = true;\n    this.validate();\n  },\n\n  manageFailingFieldTrigger: function (fieldInstance) {\n    fieldInstance._ui.failedOnce = true;\n\n    // Radio and checkboxes fields must bind every field multiple\n    if (fieldInstance.options.multiple)\n      $('[' + fieldInstance.options.namespace + 'multiple=\"' + fieldInstance.options.multiple + '\"]').each(function () {\n        if (!new RegExp('change', 'i').test($(this).parsley().options.trigger || ''))\n          return $(this).on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n      });\n\n    // Select case\n    if (fieldInstance.$element.is('select'))\n      if (!new RegExp('change', 'i').test(fieldInstance.options.trigger || ''))\n        return fieldInstance.$element.on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n\n    // All other inputs fields\n    if (!new RegExp('keyup', 'i').test(fieldInstance.options.trigger || ''))\n      return fieldInstance.$element.on('keyup.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));\n  },\n\n  reset: function (parsleyInstance) {\n    // Reset all event listeners\n    this.actualizeTriggers(parsleyInstance);\n    parsleyInstance.$element.off('.ParsleyFailedOnce');\n\n    // Nothing to do if UI never initialized for this field\n    if ('undefined' === typeof parsleyInstance._ui)\n      return;\n\n    if ('ParsleyForm' === parsleyInstance.__class__)\n      return;\n\n    // Reset all errors' li\n    parsleyInstance._ui.$errorsWrapper\n      .removeClass('filled')\n      .children()\n      .remove();\n\n    // Reset validation class\n    this._resetClass(parsleyInstance);\n\n    // Reset validation flags and last validation result\n    parsleyInstance._ui.validatedOnce = false;\n    parsleyInstance._ui.lastValidationResult = [];\n    parsleyInstance._ui.validationInformationVisible = false;\n    parsleyInstance._ui.failedOnce = false;\n  },\n\n  destroy: function (parsleyInstance) {\n    this.reset(parsleyInstance);\n\n    if ('ParsleyForm' === parsleyInstance.__class__)\n      return;\n\n    if ('undefined' !== typeof parsleyInstance._ui)\n      parsleyInstance._ui.$errorsWrapper.remove();\n\n    delete parsleyInstance._ui;\n  },\n\n  _successClass: function (fieldInstance) {\n    fieldInstance._ui.validationInformationVisible = true;\n    fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.errorClass).addClass(fieldInstance.options.successClass);\n  },\n  _errorClass: function (fieldInstance) {\n    fieldInstance._ui.validationInformationVisible = true;\n    fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).addClass(fieldInstance.options.errorClass);\n  },\n  _resetClass: function (fieldInstance) {\n    fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).removeClass(fieldInstance.options.errorClass);\n  }\n};\n\nexport default ParsleyUI;\n","import ParsleyAbstract from 'parsley/abstract';\nimport ParsleyUtils from 'parsley/utils';\n\nvar ParsleyForm = function (element, domOptions, options) {\n  this.__class__ = 'ParsleyForm';\n  this.__id__ = ParsleyUtils.generateID();\n\n  this.$element = $(element);\n  this.domOptions = domOptions;\n  this.options = options;\n  this.parent = window.Parsley;\n\n  this.fields = [];\n  this.validationResult = null;\n};\n\nvar statusMapping = { pending: null, resolved: true, rejected: false };\n\nParsleyForm.prototype = {\n  onSubmitValidate: function (event) {\n    var that = this;\n\n    // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n    if (true === event.parsley)\n      return;\n\n    // Because some validations might be asynchroneous,\n    // we cancel this submit and will fake it after validation.\n    event.stopImmediatePropagation();\n    event.preventDefault();\n\n    this.whenValidate(undefined, undefined, event)\n      .done(function() { that._submit(); })\n      .always(function() { that._submitSource = null; });\n\n    return this;\n  },\n\n  // internal\n  // _submit submits the form, this time without going through the validations.\n  // Care must be taken to \"fake\" the actual submit button being clicked.\n  _submit: function() {\n    if (false === this._trigger('submit'))\n      return;\n    this.$element.find('.parsley_synthetic_submit_button').remove();\n    if (this._submitSource) {\n      $('<input class=\".parsley_synthetic_submit_button\" type=\"hidden\">')\n      .attr('name', this._submitSource.name)\n      .attr('value', this._submitSource.value)\n      .appendTo(this.$element);\n    }\n    this.$element.trigger($.extend($.Event('submit'), { parsley: true }));\n  },\n\n  // Performs validation on fields while triggering events.\n  // @returns `true` if al validations succeeds, `false`\n  // if a failure is immediately detected, or `null`\n  // if dependant on a promise.\n  // Prefer `whenValidate`.\n  validate: function (group, force, event) {\n    return statusMapping[ this.whenValidate(group, force, event).state() ];\n  },\n\n  whenValidate: function (group, force, event) {\n    var that = this;\n    this.submitEvent = event;\n    this.validationResult = true;\n\n    // fire validate event to eventually modify things before very validation\n    this._trigger('validate');\n\n    // Refresh form DOM options and form's fields that could have changed\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(function(){\n      return $.map(this.fields, function(field) {\n        // do not validate a field if not the same as given validation group\n        if (!group || that._isFieldInGroup(field, group))\n          return field.whenValidate(force);\n      });\n    });\n    return $.when.apply($, promises)\n      .done(  function() { that._trigger('success'); })\n      .fail(  function() { that.validationResult = false; that._trigger('error'); })\n      .always(function() { that._trigger('validated'); });\n  },\n\n  // Iterate over refreshed fields, and stop on first failure.\n  // Returns `true` if all fields are valid, `false` if a failure is detected\n  // or `null` if the result depends on an unresolved promise.\n  // Prefer using `whenValid` instead.\n  isValid: function (group, force) {\n    return statusMapping[ this.whenValid(group, force).state() ];\n  },\n\n  // Iterate over refreshed fields and validate them.\n  // Returns a promise.\n  // A validation that immediately fails will interrupt the validations.\n  whenValid: function (group, force) {\n    var that = this;\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(function(){\n      return $.map(this.fields, function(field) {\n        // do not validate a field if not the same as given validation group\n        if (!group || that._isFieldInGroup(field, group))\n          return field.whenValid(force);\n      });\n    });\n    return $.when.apply($, promises);\n  },\n\n  _isFieldInGroup: function (field, group) {\n    if($.isArray(field.options.group))\n      return -1 !== $.inArray(group, field.options.group);\n    return field.options.group === group;\n  },\n\n  _refreshFields: function () {\n    return this.actualizeOptions()._bindFields();\n  },\n\n  _bindFields: function () {\n    var self = this,\n      oldFields = this.fields;\n\n    this.fields = [];\n    this.fieldsMappedById = {};\n\n    this._withoutReactualizingFormOptions(function(){\n      this.$element\n      .find(this.options.inputs)\n      .not(this.options.excluded)\n      .each(function () {\n        var fieldInstance = new Parsley.Factory(this, {}, self);\n\n        // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children\n        if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded))\n          if ('undefined' === typeof self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {\n            self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;\n            self.fields.push(fieldInstance);\n          }\n      });\n\n      $(oldFields).not(self.fields).each(function () {\n        this._trigger('reset');\n      });\n    });\n    return this;\n  },\n\n  // Internal only.\n  // Looping on a form's fields to do validation or similar\n  // will trigger reactualizing options on all of them, which\n  // in turn will reactualize the form's options.\n  // To avoid calling actualizeOptions so many times on the form\n  // for nothing, _withoutReactualizingFormOptions temporarily disables\n  // the method actualizeOptions on this form while `fn` is called.\n  _withoutReactualizingFormOptions: function (fn) {\n    var oldActualizeOptions = this.actualizeOptions;\n    this.actualizeOptions = function() { return this; };\n    var result = fn.call(this); // Keep the current `this`.\n    this.actualizeOptions = oldActualizeOptions;\n    return result;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  // Returns true iff event is not interrupted and default not prevented.\n  _trigger: function (eventName) {\n    return this.trigger('form:' + eventName);\n  }\n\n};\n\nexport default ParsleyForm;\n","import ParsleyUtils from 'parsley/utils';\nimport ParsleyValidator from 'parsley/validator';\n\n\nvar ConstraintFactory = function (parsleyField, name, requirements, priority, isDomConstraint) {\n  if (!new RegExp('ParsleyField').test(parsleyField.__class__))\n    throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');\n\n  var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n  var validator = new ParsleyValidator(validatorSpec);\n\n  $.extend(this, {\n    validator: validator,\n    name: name,\n    requirements: requirements,\n    priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n    isDomConstraint: true === isDomConstraint\n  });\n  this._parseRequirements(parsleyField.options);\n};\n\nvar capitalize = function(str) {\n  var cap = str[0].toUpperCase();\n  return cap + str.slice(1);\n};\n\nConstraintFactory.prototype = {\n  validate: function(value, instance) {\n    var args = this.requirementList.slice(0); // Make copy\n    args.unshift(value);\n    args.push(instance);\n    return this.validator.validate.apply(this.validator, args);\n  },\n\n  _parseRequirements: function(options) {\n    var that = this;\n    this.requirementList = this.validator.parseRequirements(this.requirements, function(key) {\n      return options[that.name + capitalize(key)];\n    });\n  }\n};\n\nexport default ConstraintFactory;\n\n","import ConstraintFactory from 'parsley/factory/constraint';\nimport ParsleyUI from 'parsley/ui';\nimport ParsleyUtils from 'parsley/utils';\n\nvar ParsleyField = function (field, domOptions, options, parsleyFormInstance) {\n  this.__class__ = 'ParsleyField';\n  this.__id__ = ParsleyUtils.generateID();\n\n  this.$element = $(field);\n\n  // Set parent if we have one\n  if ('undefined' !== typeof parsleyFormInstance) {\n    this.parent = parsleyFormInstance;\n  }\n\n  this.options = options;\n  this.domOptions = domOptions;\n\n  // Initialize some properties\n  this.constraints = [];\n  this.constraintsByName = {};\n  this.validationResult = [];\n\n  // Bind constraints\n  this._bindConstraints();\n};\n\nvar statusMapping = { pending: null, resolved: true, rejected: false };\n\nParsleyField.prototype = {\n  // # Public API\n  // Validate field and trigger some events for mainly `ParsleyUI`\n  // @returns `true`, an array of the validators that failed, or\n  // `null` if validation is not finished. Prefer using whenValidate\n  validate: function (force) {\n    var promise = this.whenValidate(force);\n    switch (promise.state()) {\n      case 'pending': return null;\n      case 'resolved': return true;\n      case 'rejected': return this.validationResult;\n    }\n  },\n\n  // Validate field and trigger some events for mainly `ParsleyUI`\n  // @returns a promise that succeeds only when all validations do.\n  whenValidate: function (force) {\n    var that = this;\n\n    this.value = this.getValue();\n\n    // Field Validate event. `this.value` could be altered for custom needs\n    this._trigger('validate');\n\n    return this.whenValid(force, this.value)\n      .done(function()   { that._trigger('success'); })\n      .fail(function()   { that._trigger('error'); })\n      .always(function() { that._trigger('validated'); });\n  },\n\n  hasConstraints: function () {\n    return 0 !== this.constraints.length;\n  },\n\n  // An empty optional field does not need validation\n  needsValidation: function (value) {\n    if ('undefined' === typeof value)\n      value = this.getValue();\n\n    // If a field is empty and not required, it is valid\n    // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n    if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\n      return false;\n\n    return true;\n  },\n\n  // Just validate field. Do not trigger any event.\n  // Returns `true` iff all constraints pass, `false` if there are failures,\n  // or `null` if the result can not be determined yet (depends on a promise)\n  // Prefer using `whenValid`.\n  isValid: function (force, value) {\n    return statusMapping[this.whenValid(force, value).state()];\n  },\n\n  whenValid: function (force, value) {\n    // Recompute options and rebind constraints to have latest changes\n    this.refreshConstraints();\n    this.validationResult = true;\n\n    // A field without constraint is valid\n    if (!this.hasConstraints())\n      return $.when();\n\n    // Value could be passed as argument, needed to add more power to 'parsley:field:validate'\n    if ('undefined' === typeof value || null === value)\n      value = this.getValue();\n\n    if (!this.needsValidation(value) && true !== force)\n      return $.when();\n\n    var groupedConstraints = this._getGroupedConstraints();\n    var promises = [];\n    var that = this;\n    $.each(groupedConstraints, function(_, constraints) {\n      // Process one group of constraints at a time, we validate the constraints\n      // and combine the promises together.\n      var promise = $.when.apply($,\n        $.map(constraints, $.proxy(that, '_validateConstraint', value))\n      );\n      promises.push(promise);\n      if (promise.state() === 'rejected')\n        return false; // Interrupt processing if a group has already failed\n    });\n    return $.when.apply($, promises);\n  },\n\n  // @returns a promise\n  _validateConstraint: function(value, constraint) {\n    var that = this;\n    var result = constraint.validate(value, this);\n    // Map false to a failed promise\n    if (false === result)\n      result = $.Deferred().reject();\n    // Make sure we return a promise and that we record failures\n    return $.when(result).fail(function() {\n      if (true === that.validationResult)\n        that.validationResult = [];\n      that.validationResult.push({assert: constraint});\n    });\n  },\n\n  // @returns Parsley field computed value that could be overrided or configured in DOM\n  getValue: function () {\n    var value;\n\n    // Value could be overriden in DOM or with explicit options\n    if ('function' === typeof this.options.value)\n      value = this.options.value(this);\n    else if ('undefined' !== typeof this.options.value)\n      value = this.options.value;\n    else\n      value = this.$element.val();\n\n    // Handle wrong DOM or configurations\n    if ('undefined' === typeof value || null === value)\n      return '';\n\n    return this._handleWhitespace(value);\n  },\n\n  // Actualize options that could have change since previous validation\n  // Re-bind accordingly constraints (could be some new, removed or updated)\n  refreshConstraints: function () {\n    return this.actualizeOptions()._bindConstraints();\n  },\n\n  /**\n  * Add a new constraint to a field\n  *\n  * @method addConstraint\n  * @param {String}   name\n  * @param {Mixed}    requirements      optional\n  * @param {Number}   priority          optional\n  * @param {Boolean}  isDomConstraint   optional\n  */\n  addConstraint: function (name, requirements, priority, isDomConstraint) {\n\n    if (window.Parsley._validatorRegistry.validators[name]) {\n      var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);\n\n      // if constraint already exist, delete it and push new version\n      if ('undefined' !== this.constraintsByName[constraint.name])\n        this.removeConstraint(constraint.name);\n\n      this.constraints.push(constraint);\n      this.constraintsByName[constraint.name] = constraint;\n    }\n\n    return this;\n  },\n\n  // Remove a constraint\n  removeConstraint: function (name) {\n    for (var i = 0; i < this.constraints.length; i++)\n      if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n    delete this.constraintsByName[name];\n    return this;\n  },\n\n  // Update a constraint (Remove + re-add)\n  updateConstraint: function (name, parameters, priority) {\n    return this.removeConstraint(name)\n      .addConstraint(name, parameters, priority);\n  },\n\n  // # Internals\n\n  // Internal only.\n  // Bind constraints from config + options + DOM\n  _bindConstraints: function () {\n    var constraints = [], constraintsByName = {};\n\n    // clean all existing DOM constraints to only keep javascript user constraints\n    for (var i = 0; i < this.constraints.length; i++)\n      if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n    this.constraints = constraints;\n    this.constraintsByName = constraintsByName;\n\n    // then re-add Parsley DOM-API constraints\n    for (var name in this.options)\n      this.addConstraint(name, this.options[name], undefined, true);\n\n    // finally, bind special HTML5 constraints\n    return this._bindHtml5Constraints();\n  },\n\n  // Internal only.\n  // Bind specific HTML5 constraints to be HTML5 compliant\n  _bindHtml5Constraints: function () {\n    // html5 required\n    if (this.$element.hasClass('required') || this.$element.attr('required'))\n      this.addConstraint('required', true, undefined, true);\n\n    // html5 pattern\n    if ('string' === typeof this.$element.attr('pattern'))\n      this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n    // range\n    if ('undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n    // HTML5 min\n    else if ('undefined' !== typeof this.$element.attr('min'))\n      this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n    // HTML5 max\n    else if ('undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n\n    // length\n    if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n    // HTML5 minlength\n    else if ('undefined' !== typeof this.$element.attr('minlength'))\n      this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n    // HTML5 maxlength\n    else if ('undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n\n    // html5 types\n    var type = this.$element.attr('type');\n\n    if ('undefined' === typeof type)\n      return this;\n\n    // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n    if ('number' === type) {\n      if (('undefined' === typeof this.$element.attr('step')) || (0 === parseFloat(this.$element.attr('step')) % 1)) {\n        return this.addConstraint('type', 'integer', undefined, true);\n      } else {\n        return this.addConstraint('type', 'number', undefined, true);\n      }\n    // Regular other HTML5 supported types\n    } else if (/^(email|url|range)$/i.test(type)) {\n      return this.addConstraint('type', type, undefined, true);\n    }\n    return this;\n  },\n\n  // Internal only.\n  // Field is required if have required constraint without `false` value\n  _isRequired: function () {\n    if ('undefined' === typeof this.constraintsByName.required)\n      return false;\n\n    return false !== this.constraintsByName.required.requirements;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  _trigger: function (eventName) {\n    return this.trigger('field:' + eventName);\n  },\n\n  // Internal only\n  // Handles whitespace in a value\n  // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n  // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n  _handleWhitespace: function (value) {\n    if (true === this.options.trimValue)\n      ParsleyUtils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n    if ('squish' === this.options.whitespace)\n      value = value.replace(/\\s{2,}/g, ' ');\n\n    if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\n      value = ParsleyUtils.trimString(value);\n\n    return value;\n  },\n\n  // Internal only.\n  // Returns the constraints, grouped by descending priority.\n  // The result is thus an array of arrays of constraints.\n  _getGroupedConstraints: function () {\n    if (false === this.options.priorityEnabled)\n      return [this.constraints];\n\n    var groupedConstraints = [];\n    var index = {};\n\n    // Create array unique of priorities\n    for (var i = 0; i < this.constraints.length; i++) {\n      var p = this.constraints[i].priority;\n      if (!index[p])\n        groupedConstraints.push(index[p] = []);\n      index[p].push(this.constraints[i]);\n    }\n    // Sort them by priority DESC\n    groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\n\n    return groupedConstraints;\n  }\n\n};\n\nexport default ParsleyField;\n","var ParsleyMultiple = function () {\n  this.__class__ = 'ParsleyFieldMultiple';\n};\n\nParsleyMultiple.prototype = {\n  // Add new `$element` sibling for multiple field\n  addElement: function ($element) {\n    this.$elements.push($element);\n\n    return this;\n  },\n\n  // See `ParsleyField.refreshConstraints()`\n  refreshConstraints: function () {\n    var fieldConstraints;\n\n    this.constraints = [];\n\n    // Select multiple special treatment\n    if (this.$element.is('select')) {\n      this.actualizeOptions()._bindConstraints();\n\n      return this;\n    }\n\n    // Gather all constraints for each input in the multiple group\n    for (var i = 0; i < this.$elements.length; i++) {\n\n      // Check if element have not been dynamically removed since last binding\n      if (!$('html').has(this.$elements[i]).length) {\n        this.$elements.splice(i, 1);\n        continue;\n      }\n\n      fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;\n\n      for (var j = 0; j < fieldConstraints.length; j++)\n        this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n    }\n\n    return this;\n  },\n\n  // See `ParsleyField.getValue()`\n  getValue: function () {\n    // Value could be overriden in DOM\n    if ('undefined' !== typeof this.options.value)\n      return this.options.value;\n\n    // Radio input case\n    if (this.$element.is('input[type=radio]'))\n      return this._findRelatedMultiple().filter(':checked').val() || '';\n\n    // checkbox input case\n    if (this.$element.is('input[type=checkbox]')) {\n      var values = [];\n\n      this._findRelatedMultiple().filter(':checked').each(function () {\n        values.push($(this).val());\n      });\n\n      return values;\n    }\n\n    // Select multiple case\n    if (this.$element.is('select') && null === this.$element.val())\n      return [];\n\n    // Default case that should never happen\n    return this.$element.val();\n  },\n\n  _init: function () {\n    this.$elements = [this.$element];\n\n    return this;\n  }\n};\n\nexport default ParsleyMultiple;\n","import ParsleyUtils from 'parsley/utils';\nimport ParsleyAbstract from 'parsley/abstract';\nimport ParsleyForm from 'parsley/form';\nimport ParsleyField from 'parsley/field';\nimport ParsleyMultiple from 'parsley/multiple';\n\nvar ParsleyFactory = function (element, options, parsleyFormInstance) {\n  this.$element = $(element);\n\n  // If the element has already been bound, returns its saved Parsley instance\n  var savedparsleyFormInstance = this.$element.data('Parsley');\n  if (savedparsleyFormInstance) {\n\n    // If the saved instance has been bound without a ParsleyForm parent and there is one given in this call, add it\n    if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n      savedparsleyFormInstance.parent = parsleyFormInstance;\n      savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n    }\n\n    return savedparsleyFormInstance;\n  }\n\n  // Parsley must be instantiated with a DOM element or jQuery $element\n  if (!this.$element.length)\n    throw new Error('You must bind Parsley on an existing element.');\n\n  if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__)\n    throw new Error('Parent instance must be a ParsleyForm instance');\n\n  this.parent = parsleyFormInstance || window.Parsley;\n  return this.init(options);\n};\n\nParsleyFactory.prototype = {\n  init: function (options) {\n    this.__class__ = 'Parsley';\n    this.__version__ = '@@version';\n    this.__id__ = ParsleyUtils.generateID();\n\n    // Pre-compute options\n    this._resetOptions(options);\n\n    // A ParsleyForm instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n    if (this.$element.is('form') || (ParsleyUtils.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\n      return this.bind('parsleyForm');\n\n    // Every other element is bound as a `ParsleyField` or `ParsleyFieldMultiple`\n    return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n  },\n\n  isMultiple: function () {\n    return (this.$element.is('input[type=radio], input[type=checkbox]')) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));\n  },\n\n  // Multiples fields are a real nightmare :(\n  // Maybe some refactoring would be appreciated here...\n  handleMultiple: function () {\n    var\n      that = this,\n      name,\n      multiple,\n      parsleyMultipleInstance;\n\n    // Handle multiple name\n    if (this.options.multiple)\n      ; // We already have our 'multiple' identifier\n    else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)\n      this.options.multiple = name = this.$element.attr('name');\n    else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)\n      this.options.multiple = this.$element.attr('id');\n\n    // Special select multiple input\n    if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n      this.options.multiple = this.options.multiple || this.__id__;\n      return this.bind('parsleyFieldMultiple');\n\n    // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n    } else if (!this.options.multiple) {\n      ParsleyUtils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n      return this;\n    }\n\n    // Remove special chars\n    this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n    // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n    if ('undefined' !== typeof name) {\n      $('input[name=\"' + name + '\"]').each(function () {\n        if ($(this).is('input[type=radio], input[type=checkbox]'))\n          $(this).attr(that.options.namespace + 'multiple', that.options.multiple);\n      });\n    }\n\n    // Check here if we don't already have a related multiple instance saved\n    var $previouslyRelated = this._findRelatedMultiple();\n    for (var i = 0; i < $previouslyRelated.length; i++) {\n      parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n      if ('undefined' !== typeof parsleyMultipleInstance) {\n\n        if (!this.$element.data('ParsleyFieldMultiple')) {\n          parsleyMultipleInstance.addElement(this.$element);\n        }\n\n        break;\n      }\n    }\n\n    // Create a secret ParsleyField instance for every multiple field. It will be stored in `data('ParsleyFieldMultiple')`\n    // And will be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance\n    this.bind('parsleyField', true);\n\n    return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n  },\n\n  // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`\n  bind: function (type, doNotStore) {\n    var parsleyInstance;\n\n    switch (type) {\n      case 'parsleyForm':\n        parsleyInstance = $.extend(\n          new ParsleyForm(this.$element, this.domOptions, this.options),\n          window.ParsleyExtend\n        )._bindFields();\n        break;\n      case 'parsleyField':\n        parsleyInstance = $.extend(\n          new ParsleyField(this.$element, this.domOptions, this.options, this.parent),\n          window.ParsleyExtend\n        );\n        break;\n      case 'parsleyFieldMultiple':\n        parsleyInstance = $.extend(\n          new ParsleyField(this.$element, this.domOptions, this.options, this.parent),\n          new ParsleyMultiple(),\n          window.ParsleyExtend\n        )._init();\n        break;\n      default:\n        throw new Error(type + 'is not a supported Parsley type');\n    }\n\n    if (this.options.multiple)\n      ParsleyUtils.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n    if ('undefined' !== typeof doNotStore) {\n      this.$element.data('ParsleyFieldMultiple', parsleyInstance);\n\n      return parsleyInstance;\n    }\n\n     // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n    this.$element.data('Parsley', parsleyInstance);\n\n    // Tell the world we have a new ParsleyForm or ParsleyField instance!\n    parsleyInstance._trigger('init');\n\n    return parsleyInstance;\n  }\n};\n\nexport default ParsleyFactory;\n","//     Parsley.js @@version\n//     http://parsleyjs.org\n//     (c) 2012-2015 Guillaume Potier, Wisembly\n//     Parsley may be freely distributed under the MIT license.\n\nimport $ from 'jQuery';\nimport ParsleyUtils from 'parsley/utils';\nimport ParsleyDefaults from 'parsley/defaults';\nimport ParsleyAbstract from 'parsley/abstract';\nimport ParsleyValidatorRegistry from 'parsley/validator_registry';\nimport ParsleyUI from 'parsley/ui';\nimport ParsleyForm from 'parsley/form';\nimport ParsleyField from 'parsley/field';\nimport ParsleyMultiple from 'parsley/multiple';\nimport ParsleyFactory from 'parsley/factory';\nimport PubSub from 'parsley/pubsub';\n// import i18nEN from 'i18n/en';\n\n// Inherit `on`, `off` & `trigger` to Parsley:\nvar Parsley = $.extend(new ParsleyAbstract(), {\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: ParsleyFactory,\n    version: '@@version'\n  });\n\n// Supplement ParsleyField and Form with ParsleyAbstract\n// This way, the constructors will have access to those methods\n$.extend(ParsleyField.prototype, ParsleyAbstract.prototype);\n$.extend(ParsleyForm.prototype, ParsleyAbstract.prototype);\n// Inherit actualizeOptions and _resetOptions:\n$.extend(ParsleyFactory.prototype, ParsleyAbstract.prototype);\n\n// ### jQuery API\n// `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n$.fn.parsley = $.fn.psly = function (options) {\n  if (this.length > 1) {\n    var instances = [];\n\n    this.each(function () {\n      instances.push($(this).parsley(options));\n    });\n\n    return instances;\n  }\n\n  // Return undefined if applied to non existing DOM element\n  if (!$(this).length) {\n    ParsleyUtils.warn('You must bind Parsley on an existing element.');\n\n    return;\n  }\n\n  return new ParsleyFactory(this, options);\n};\n\n// ### ParsleyField and ParsleyForm extension\n// Ensure the extension is now defined if it wasn't previously\nif ('undefined' === typeof window.ParsleyExtend)\n  window.ParsleyExtend = {};\n\n// ### Parsley config\n// Inherit from ParsleyDefault, and copy over any existing values\nParsley.options = $.extend(ParsleyUtils.objectCreate(ParsleyDefaults), window.ParsleyConfig);\nwindow.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n// ### Globals\nwindow.Parsley = window.psly = Parsley;\nwindow.ParsleyUtils = ParsleyUtils;\n\n// ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\nvar registry = window.Parsley._validatorRegistry = new ParsleyValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\nwindow.ParsleyValidator = {};\n$.each('setLocale addCatalog addMessage getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n  window.Parsley[method] = $.proxy(registry, method);\n  window.ParsleyValidator[method] = function () {\n    ParsleyUtils.warnOnce('Accessing the method `'+ method +'` through ParsleyValidator is deprecated. Simply call `window.Parsley.' + method + '(...)`');\n    return window.Parsley[method].apply(window.Parsley, arguments);\n  };\n});\n\n// ### ParsleyUI\n// UI is a separate class that only listens to some events and then modifies the DOM accordingly\n// Could be overriden by defining a `window.ParsleyConfig.ParsleyUI` appropriate class (with `listen()` method basically)\nwindow.ParsleyUI = 'function' === typeof window.ParsleyConfig.ParsleyUI ?\n  new window.ParsleyConfig.ParsleyUI().listen() : new ParsleyUI().listen();\n\n// ### PARSLEY auto-binding\n// Prevent it by setting `ParsleyConfig.autoBind` to `false`\nif (false !== window.ParsleyConfig.autoBind) {\n  $(function () {\n    // Works only on `data-parsley-validate`.\n    if ($('[data-parsley-validate]').length)\n      $('[data-parsley-validate]').parsley();\n  });\n}\n\nexport default Parsley;\n"],"sourceRoot":"/source/"}